
// Структура, хранящая глобальные параметры скрипта
// Используется в качестве пространства имен, разрешающего конфликты 
// между настройками и локальными идентификаторами
Перем мПараметры;
Перем мКонтекстВыполнения; // Временные данные скрипта
Перем мРежимОтладки;
Перем мРежимУплотнения;
Перем мРежимСохраненияАрхивов;
Перем мНомерОчереди;
Перем мОсталосьОпераций;

Перем юТест; // объект юнит-тестов

Перем _тест_СтруктураПараметров; // - удалить

Функция Версия() Экспорт
	Возврат "1.1.0.0";
КонецФункции

Функция ПолучитьСписокТестов(ЮнитТестирование) Экспорт
	
	юТест = ЮнитТестирование;
	
	ВсеТесты = Новый Массив;

	ВсеТесты.Добавить("ТестДолжен_ЗарегистрироватьИУдалитьВременныеФайлы");
	//ВсеТесты.Добавить("Тест_ДолженПолучитьМаксимальнуюВерсию83");
	ВсеТесты.Добавить("Тест_ДолженВыполнитьПолнуюВыгрузкуЧерезПараметрыЗапуска");
	ВсеТесты.Добавить("Тест_ДолженСоздатьПустуюБазуПоФайлуКонфигурации");
	ВсеТесты.Добавить("Тест_ДолженСоздатьПустуюБазуПоФайлуКонфигурации_Платформа82");
	ВсеТесты.Добавить("Тест_ДолженВыгрузитьМодули");
	ВсеТесты.Добавить("Тест_ДолженРазложитьМодули1СПоПапкамСогласноИерархииМетаданных");
	ВсеТесты.Добавить("Тест_ДолженРазложитьМодули1СПоПапкамСогласноИерархииМетаданных_Платформа82");
	// ВсеТесты.Добавить("Тест_ДолженСобратьМодули1СИзПапокСогласноИерархииВОднуЛинейнуюПапку");
	// ВсеТесты.Добавить("Тест_ДолженПолучитьТаблицуОписанияВсехИБ");
	// ВсеТесты.Добавить("Тест_ДолженПолучитьПутьПлатформы1СПоПутиИБ");
	ВсеТесты.Добавить("Тест_ДолженУбратьОбрамляющиеКавычкиЕслиЕсть");
	ВсеТесты.Добавить("Тест_ДолженПолучитьФайлВерсийХранилища");
	ВсеТесты.Добавить("Тест_ДолженПрочитатьФайлВерсийИзХранилища1С");
	ВсеТесты.Добавить("Тест_ДолженПрочитатьФайлПользователейИзХранилища1С");
	ВсеТесты.Добавить("Тест_ДолженПодготовитьРепозитарийКСинхронизацииСХранилищем");
	ВсеТесты.Добавить("Тест_ДолженПрочитатьФайлВерсийСИменамиПользователейИзХранилища1С");
	// ВсеТесты.Добавить("Тест_ТестДолженПоНомеруВерсииСохранитьКонфигурациюИзХранилища1С");
	// ВсеТесты.Добавить("Тест_ТестДолженПоНомеруВерсииРазобратьКонфигурациюИзХранилища1С");
	// ВсеТесты.Добавить("Тест_ДолженРазложитьМодули1СпоНомеруВерсииХранилища1С");
	ВсеТесты.Добавить("ТестДолжен_СинхронизироватьХранилищеКонфигурацийСГит");
	ВсеТесты.Добавить("ТестДолжен_ОпределитьЧтоТребуетсяСинхронизацияСГит");
	ВсеТесты.Добавить("ТестДолжен_ВыполнитьКоммитФайловВГит");
	ВсеТесты.Добавить("ТестДолжен_ПроверитьЧтениеФайлаАвторовГит");
	ВсеТесты.Добавить("ТестДолжен_ПроверитьОтсутствиеФайлаAUTHORS");
	ВсеТесты.Добавить("ТестДолжен_ПроверитьДанныеВФайлеAUTHORS");
	ВсеТесты.Добавить("ТестДолжен_ПроверитьНеполнотуВФайлеAUTHORS");
	ВсеТесты.Добавить("ТестДолжен_ВыполнитьGitPush");
	ВсеТесты.Добавить("ТестДолжен_ВыполнитьGitPull");
	
	Возврат ВсеТесты;
	
КонецФункции

//////////////////////////////////////////////////////////////////////////////////
// ПРОГРАММНЫЙ ИНТЕРФЕЙС
//

// Инициализация

Функция ПолучитьПараметрыИнициализации() Экспорт
	
	Параметры = Новый Структура;
	Параметры.Вставить("РабочийКаталог", "");
	Параметры.Вставить("ПутьКПлатформе83", ПолучитьПутьПлатформы83());
	Параметры.Вставить("ДоменПочтыДляGit", "localhost");
	Параметры.Вставить("ПутьКФайлуХранилища1С", ""); // вопрос
	Параметры.Вставить("ПользовательИБ", "");// вопрос
	Параметры.Вставить("ПарольИБ", "");// вопрос
	Параметры.Вставить("ПользовательХранилища", "");// вопрос
	Параметры.Вставить("ПарольХранилища", "");// вопрос
	Параметры.Вставить("НомерВерсииХранилища", ""); // вопрос
	Параметры.Вставить("ВерсияПлатформыИБ", "8.3"); // сделать в виде маски, как в окне стартера платформы
	Параметры.Вставить("ПутьGit", "C:\Program Files (x86)\Git\cmd\git.exe");
	
	Возврат Параметры;
	
КонецФункции

Функция РежимОтладки(Знач УстановитьОтладку = Неопределено) Экспорт

	ТекущийРежим = мРежимОтладки;
	Если УстановитьОтладку <> Неопределено Тогда
		мРежимОтладки = УстановитьОтладку;
	КонецЕсли;

	Возврат ТекущийРежим;
	
КонецФункции

Функция НомерОчереди(Знач НомерОчереди = Неопределено) Экспорт

	ТекущийНомерОчереди = мНомерОчереди;
	Если НомерОчереди <> Неопределено Тогда
		мНомерОчереди = НомерОчереди;
	КонецЕсли;
	
	Возврат ТекущийНомерОчереди;
	
КонецФункции

Функция ОсталосьОпераций(Знач НачальноеКоличество = Неопределено) Экспорт

	Если НачальноеКоличество <> Неопределено Тогда
		мОсталосьОпераций = НачальноеКоличество;
	Иначе
		мОсталосьОпераций = мОсталосьОпераций - 1;
	КонецЕсли;
	
	Возврат мОсталосьОпераций;
	
КонецФункции


Функция РежимУплотнения(Знач УстановитьУплотнение = Неопределено) Экспорт

	ТекущийРежим = мРежимУплотнения;
	Если УстановитьУплотнение <> Неопределено Тогда
		мРежимУплотнения = УстановитьУплотнение;
	КонецЕсли;

	Возврат ТекущийРежим;
	
КонецФункции

Функция РежимСохраненияАрхивов(Знач УстановитьСохранениеАрхивов = Неопределено) Экспорт

	ТекущийРежим = мРежимСохраненияАрхивов;
	Если УстановитьСохранениеАрхивов <> Неопределено Тогда
		мРежимСохраненияАрхивов = УстановитьСохранениеАрхивов;
	КонецЕсли;

	Возврат ТекущийРежим;
	
КонецФункции

Процедура Инициализация(Знач Параметры) Экспорт
	
	Если мПараметры <> Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	мПараметры = Параметры;
	
	мКонтекстВыполнения = Новый Структура;
	мКонтекстВыполнения.Вставить("ВременныеФайлы", Новый Массив);
	
	Если ПустаяСтрока(мПараметры.РабочийКаталог) Тогда
		мПараметры.РабочийКаталог = КаталогРабочихФайлов();
	Иначе
		Файл = Новый Файл(мПараметры.РабочийКаталог);
		Если Не Файл.Существует() или Не Файл.ЭтоКаталог() Тогда
			ВызватьИсключение "Рабочий каталог <"+мПараметры.РабочийКаталог+"> не может быть использован";
		КонецЕсли;		
	КонецЕсли;
	
	мПараметры.РабочийКаталог = ДополнитьСлешВПуть(мПараметры.РабочийКаталог);	
	
	мКонтекстВыполнения.Вставить("ФайлПрограммыРаспаковки", Новый Файл("libs\unpackV8.exe"));
	Если Не мКонтекстВыполнения.ФайлПрограммыРаспаковки.Существует() Тогда
		ВызватьИсключение "Не обнаружен файл программы распаковки: <"+мКонтекстВыполнения.ФайлПрограммыРаспаковки.ПолноеИмя+">";
	КонецЕсли;
	
	ФайлDLL = Новый Файл("libs\zlib1.dll");
	Если НЕ ФайлDLL.Существует() Тогда
		ВызватьИсключение "Не обнаружена библиотека zlib1: <"+ФайлDLL.ПолноеИмя+">";
	КонецЕсли; 

	ФайлGit = Новый Файл(мПараметры.ПутьGit);
	ВывестиОтладочноеСообщение("Проверяю исполняемый файл git.exe: <"+ФайлGit.ПолноеИмя+">");	
	
	Если НЕ ФайлGit.Существует() Тогда
		ВызватьИсключение "Не обнаружен исполняемый файл git.exe: <"+ФайлGit.ПолноеИмя+">";
	КонецЕсли; 
	
	Если ПустаяСтрока(мПараметры.ПутьКПлатформе83) Тогда
		мПараметры.ПутьКПлатформе83 = ПолучитьПутьПлатформы83();
	КонецЕсли;
	
КонецПроцедуры

Функция ПолучитьПутьКВерсииПлатформы(Знач ВерсияПлатформы) Экспорт

	Если Лев(ВерсияПлатформы, 2) <> "8." Тогда
		ВызватьИсключение "Неверная версия платформы <"+ВерсияПлатформы+">";
	КонецЕсли;	
	
	путьProgramFiles = "C:\Program Files (x86)\";
	файлProgramFiles = Новый Файл(путьProgramFiles);
	Если Не файлProgramFiles.Существует() Тогда
		путьProgramFiles = "C:\Program Files\";
		файлProgramFiles = Новый Файл(путьProgramFiles);
		Проверить(файлProgramFiles.Существует(), "Должен существовать путь к Program Files или Program Files (86)");
	КонецЕсли;
	
	СписокСтрок = РазложитьСтрокуВМассивПодстрок(ВерсияПлатформы, ".", Ложь);
	Если СписокСтрок.Количество() < 2 Тогда
		ВызватьИсключение "Маска версии платформы должна содержать, как минимум, минорную и мажорную версию, т.е. Maj.Min[.Release][.Build]";
	КонецЕсли;
	
	МажорнаяВерсия = СписокСтрок[0];
	МинорнаяВерсия = СписокСтрок[1];
	
	Если МинорнаяВерсия = "3" Тогда // 8.3
		путьКПлатформе = путьProgramFiles + "1cv8\";
	ИначеЕсли МинорнаяВерсия = "2" Тогда // 8.2
		путьКПлатформе = путьProgramFiles + "1cv82\";	
	ИначеЕсли МинорнаяВерсия = "1" Тогда // 8.1
		путьКПлатформе = путьProgramFiles + "1cv81\";
	Иначе
		ВызватьИсключение "Неверная версия платформы <"+ВерсияПлатформы+">";
	КонецЕсли;
	
	МассивФайлов = НайтиФайлы(путьКПлатформе, версияПлатформы+"*");
	Если МассивФайлов.Количество() = 0 Тогда
		парамОписаниеОшибки = "Не найден путь к платформе 1С <"+версияПлатформы+">";
		Возврат "";
	КонецЕсли;
	
	ИменаВерсий = Новый Массив;
	Для Каждого ЭлементМассива Из МассивФайлов Цикл
		правыйСимвол = Прав(ЭлементМассива.Имя,1);
		Если правыйСимвол < "0" или правыйСимвол > "9" Тогда
			Продолжить;
		КонецЕсли;
		ИменаВерсий.Добавить(ЭлементМассива.Имя);
	КонецЦикла;
	
	МаксВерсия = ИменаВерсий[0];
	Для Сч = 1 По ИменаВерсий.Количество()-1 Цикл
		Если МаксВерсия < ИменаВерсий[Сч] Тогда
			МаксВерсия = ИменаВерсий[Сч];
		КонецЕсли;
	КонецЦикла;
	
	НужныйПуть = Новый Файл(путьКПлатформе + МаксВерсия + "\bin\1cv8.exe");
	Если Не НужныйПуть.Существует() Тогда
		ВызватьИсключение "Ошибка определения версии платформы. Файл <"+НужныйПуть.ПолноеИмя+"> не существует";
	КонецЕсли;
	
	Возврат НужныйПуть.ПолноеИмя;
	
КонецФункции


// Методы работы с временными файлами

Функция ПолучитьВременноеИмяФайлаЛога()
	Возврат СоздатьВременныйФайл("log");
КонецФункции

Функция СоздатьВременныйФайл(Знач Расширение = Неопределено)
	Если Расширение = Неопределено Тогда
		Расширение = "tmp";
	КонецЕсли;
	Если (не ПустаяСтрока(Расширение)) и Лев(Расширение, 1) <> "."  Тогда
		Расширение = "."+Расширение;
	КонецЕсли;	
	
	Префикс = "v8up_" + ?(НомерОчереди() <> 0, "" + НомерОчереди() + "_","") ;
	БазовоеИмя = КаталогРабочихФайлов() + Префикс + Расширение;
	резИмя = СоздатьУникальныйФайл(БазовоеИмя);
	
	ЗарегистрироватьВременныйФайл(резИмя);
	
	Возврат резИмя;
КонецФункции

Функция СоздатьУникальныйФайл(Знач БазовоеИмя, Знач Счетчик = 0)

	ФайлБаза = Новый Файл(БазовоеИмя);
	Если Счетчик = 0 Тогда
		ФайлТест = ФайлБаза;
	Иначе
		ФайлТест = Новый Файл(ФайлБаза.Путь + "\" + ФайлБаза.ИмяБезРасширения + Строка(Счетчик) + ФайлБаза.Расширение);
	КонецЕсли;
	
	Если Не ФайлТест.Существует() Тогда
		ЗаписьТекста = Новый ЗаписьТекста(ФайлТест.ПолноеИмя);
		ЗаписьТекста.Закрыть(); // теперь никто не заберет это имя
		Возврат ФайлТест.ПолноеИмя;
	Иначе
		Возврат СоздатьУникальныйФайл(БазовоеИмя, Счетчик + 1);
	КонецЕсли;

КонецФункции

Функция СоздатьВременныйКаталог()
	
	Префикс = "v8up_" + ?(НомерОчереди() <> 0, "" + НомерОчереди() + "_","") ;
	БазовоеИмя = КаталогРабочихФайлов()+Префикс;
	Путь = СоздатьУникальныйКаталог(БазовоеИмя);
	ЗарегистрироватьВременныйФайл(Путь);
	
	Возврат Путь;
	
КонецФункции

Функция СоздатьУникальныйКаталог(Знач БазовоеИмя, Знач Счетчик = 0)
	
	ФайлБаза = Новый Файл(БазовоеИмя);
	Если Счетчик = 0 Тогда
		ФайлТест = ФайлБаза;
	Иначе
		ФайлТест = Новый Файл(ФайлБаза.Путь + "\" + ФайлБаза.ИмяБезРасширения + Строка(Счетчик) + ФайлБаза.Расширение);
	КонецЕсли;
	
	Если Не ФайлТест.Существует() Тогда
		СоздатьКаталог(ФайлТест.ПолноеИмя);
		Возврат ФайлТест.ПолноеИмя;
	Иначе
		Возврат СоздатьУникальныйКаталог(БазовоеИмя, Счетчик + 1);
	КонецЕсли;
	
КонецФункции

// Служебные процедуры

Функция ПодставитьПараметрыВСтроку(Знач ИсходнаяСтрока, Знач Параметр1,
					Знач Параметр2 = Неопределено,
					Знач Параметр3 = Неопределено, 
					Знач Параметр4 = Неопределено,
					Знач Параметр5 = Неопределено, 	
					Знач Параметр6 = Неопределено, 
					Знач Параметр7 = Неопределено, 
					Знач Параметр8 = Неопределено, 
					Знач Параметр9 = Неопределено)
	
	МассивПараметров = Новый Массив;
	МассивПараметров.Добавить(Параметр1);
	МассивПараметров.Добавить(Параметр2);
	МассивПараметров.Добавить(Параметр3);
	МассивПараметров.Добавить(Параметр4);
	МассивПараметров.Добавить(Параметр5);
	МассивПараметров.Добавить(Параметр6);
	МассивПараметров.Добавить(Параметр7);
	МассивПараметров.Добавить(Параметр8);
	МассивПараметров.Добавить(Параметр9);
	
	Результат = ИсходнаяСтрока;
	
	Для Сч = 1 По МассивПараметров.Количество() Цикл
		Параметр = МассивПараметров[Сч-1];
		Маркер   = "%" + Сч;
		
		Результат = СтрЗаменить(Результат, Маркер, Параметр);
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ПолучитьПутьПлатформы83()
	ПутьПлатформы1С_83 = ПолучитьПутьКВерсииПлатформы("8.3");
	ФайлПлатформы = Новый Файл(ПутьПлатформы1С_83);
	Проверить(файлПлатформы.Существует(), "Не найден путь к платформе 1С 8.3 - не существует файл <"+ПутьПлатформы1С_83+">");
	
	Возврат ПутьПлатформы1С_83;
КонецФункции

Процедура ЗаписатьОшибкуВЛог(ПутьКФайлуЛога, СтрокаОшибки) Экспорт
	
	Если НЕ ПустаяСтрока(ПутьКФайлуЛога) Тогда
		Попытка
			Запись = Новый ЗаписьТекста(ПутьКФайлуЛога, "windows-1251");
			Запись.ЗаписатьСтроку(СтрокаОшибки);
			Запись.Закрыть();
		Исключение
			Сообщить("Ошибка записи в лог ошибок "+ОписаниеОшибки());
		КонецПопытки;
	КонецЕсли;
	
КонецПроцедуры


// Работа с командными файлами

Функция СобратьКоманднуюСтроку(Знач ПереченьПараметров)
	
	СтрокаЗапуска = "";
	Для Каждого Параметр Из ПереченьПараметров Цикл
	
		СтрокаЗапуска = СтрокаЗапуска + " " + Параметр;
		
	КонецЦикла;
	
	Возврат СтрокаЗапуска;
	
КонецФункции

Функция СоздатьКомандныйФайл(Знач Путь = "")

	Если ПустаяСтрока(Путь) Тогда
		Путь = СоздатьВременныйФайл(".bat");
	КонецЕсли;
	
	ЗаписьТекста = Новый ЗаписьТекста(Путь, "cp866");
	
	Дескриптор = Новый Структура;
	Дескриптор.Вставить("ЗаписьТекста", ЗаписьТекста);
	Дескриптор.Вставить("Путь", Путь);
	
	Возврат Дескриптор;
	
КонецФункции

Процедура ДобавитьВКомандныйФайл(Знач ДескрипторКомандногоФайла, Знач Команда)
	ДескрипторКомандногоФайла.ЗаписьТекста.ЗаписатьСтроку(Команда);
КонецПроцедуры

Функция ВыполнитьКомандныйФайл(Знач ДескрипторКомандногоФайла)

	Если ДескрипторКомандногоФайла.ЗаписьТекста <> Неопределено Тогда
		ДескрипторКомандногоФайла.ЗаписьТекста.Закрыть();
	КонецЕсли;
	
	ПутьПакетногоФайла = ДескрипторКомандногоФайла.Путь;
	
	СтрокаЗапуска = "cmd.exe /C """ + ПутьПакетногоФайла + """";
	
	КодВозврата = ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(СтрокаЗапуска);
	
	Возврат КодВозврата;

КонецФункции

Функция ЗакрытьКомандныйФайл(Знач ДескрипторКомандногоФайла)
	
	Если ДескрипторКомандногоФайла.ЗаписьТекста <> Неопределено Тогда
		ДескрипторКомандногоФайла.ЗаписьТекста.Закрыть();
	КонецЕсли;
	
	Возврат ДескрипторКомандногоФайла.Путь;
	
КонецФункции

Функция СуффиксПеренаправленияВывода(Знач ИмяФайлаПриемника, Знач УчитыватьStdErr = Истина)
	Возврат "> " + ИмяФайлаПриемника + ?(УчитыватьStdErr, " 2>&1", "");
КонецФункции

Процедура ДополнитьМассив(Знач Приемник, Знач Источник)
	
	Для Каждого Элемент Из Источник Цикл
		Приемник.Добавить(Элемент);
	КонецЦикла;
	
КонецПроцедуры

Функция ОбернутьВКавычки(Знач Строка);
	Возврат """" + Строка + """";
КонецФункции

// Работа с Конфигуратором 1С

Функция КлючЗапускаВременнойБазы()

	КлючЗапускаВременнойБазы = Неопределено;
	Если Не мКонтекстВыполнения.Свойство("КлючЗапускаВременнойБазы", КлючЗапускаВременнойБазы) Тогда
		КаталогБазы = СоздатьВременныйКаталог();
		мКонтекстВыполнения.Вставить("КлючЗапускаВременнойБазы", ПодставитьПараметрыВСтроку("/F""%1""", КаталогБазы));
	КонецЕсли;

	Возврат КлючЗапускаВременнойБазы;
	
КонецФункции

Функция ЗапуститьКомандуКонфигуратора(Знач ПереченьПараметров, Знач ВерсияПлатформы = "8.3")

	РабочиеПараметры = Новый Массив;
	РабочиеПараметры.Добавить("DESIGNER");
	РабочиеПараметры.Добавить(КлючЗапускаВременнойБазы());
	ДополнитьМассив(РабочиеПараметры, ПереченьПараметров);
	
	ПутьКИсполняемомуФайлу = ОбернутьВКавычки(ПолучитьПутьКВерсииПлатформы(ВерсияПлатформы));
	КоманднаяСтрока = СобратьКоманднуюСтроку(РабочиеПараметры);
	
	Возврат ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(ПутьКИсполняемомуФайлу + " " + КоманднаяСтрока);
	
КонецФункции



Процедура РазобратьФайлКонфигурации(парамПутьКФайлуКонфигурации, парамПутьККаталогуДляВыгрузки, СтруктураПараметров = Неопределено) Экспорт 
	Строка = "pathToCF;"+парамПутьКФайлуКонфигурации+";pathOut;"+парамПутьККаталогуДляВыгрузки+";decompile;";	
	ОбработатьПараметрыЗапуска(Строка, СтруктураПараметров);
КонецПроцедуры

Процедура СобратьФайлКонфигурации(парамПутьКФайлуКонфигурации, парамПутьККаталогуДляВыгрузки, СтруктураПараметров = Неопределено) Экспорт 
	Строка = "pathToCF;"+парамПутьКФайлуКонфигурации+";pathOut;"+парамПутьККаталогуДляВыгрузки+";compile;";	
	ОбработатьПараметрыЗапуска(Строка, СтруктураПараметров);
КонецПроцедуры

Процедура СинхронизироватьХранилищеСГит(парамПутьФайлуХранилища, парамПутьККаталогуДляВыгрузки) Экспорт	
	Строка = "pathRepo;"+парамПутьФайлуХранилища+";pathOut;"+парамПутьККаталогуДляВыгрузки+";sync1ctogit;";
	ОбработатьПараметрыЗапуска(Строка);
 КонецПроцедуры

Функция РазложитьМодули1СпоНомеруВерсииХранилища1С(
			ПутьКБазе, 
			версияПлатформыДляБазы,
			Пользователь,
			Пароль,
			ПутьКХранилищу1C, 
			ПользовательХранилища,
			ПарольХранилища,
			ПутьКФайлуХранилища1С,
			НомерВерсииХранилища,
			КаталогВыгрузки,
			резКаталогВыгрузкиВсехМодулей83,
			резПутьКФайлуКонфигурации) Экспорт

	лНачало = ТекущаяДата();
	ВывестиОтладочноеСообщение("Начало "+лНачало);
	
	Инициализация(ПолучитьПараметрыИнициализации());
	
	резПутьКФайлуКонфигурации = "";
	Если НЕ ПоНомеруВерсииСохранитьКонфигурациюИзХранилища1С(ПутьКБазе, версияПлатформыДляБазы, Пользователь, Пароль, ПутьКХранилищу1C, 
		ПользовательХранилища, ПарольХранилища, ПутьКФайлуХранилища1С, НомерВерсииХранилища, резПутьКФайлуКонфигурации) Тогда
			ВывестиОтладочноеСообщение("Завершение "+ТекущаяДата());
			Возврат Ложь;
	КонецЕсли;
	//Параметры.Вставить("ПутьКФайлуКонфигурации", резПутьКФайлуКонфигурации);
	резИмяКаталогаБазы = "";
	Если НЕ РазложитьКонфигурацию1СПоПапкамСогласноИерархииМетаданных("", "", резПутьКФайлуКонфигурации, КаталогВыгрузки, резИмяКаталогаБазы)  Тогда

		ВывестиОтладочноеСообщение("Завершение "+ТекущаяДата());
		Возврат Ложь;
	КонецЕсли;

	БезопасноУдалитьВременныйФайл(резПутьКФайлуКонфигурации);

	лОкончание = ТекущаяДата();
	затратилиВремениВМинутах = (лОкончание - лНачало) / 60;
	ВывестиОтладочноеСообщение("Завершение "+лОкончание+ ", Общее время: "+затратилиВремениВМинутах+" мин.");
	
	Возврат Истина;

КонецФункции

Функция Распаковка(ФайлРаспаковки,КаталогРаспаковки)
	ФайлДляРаспаковки=Новый файл(ФайлРаспаковки);
	Если КаталогРаспаковки="" тогда
		//ИнтересующийКаталог=Новый файл(_КаталогВременныхФайлов()+ФайлДляРаспаковки.Имя+".und");
		//Если  ИнтересующийКаталог.Существует() тогда
		//	ГСЧ = Новый ГенераторСлучайныхЧисел(ТекущаяДата()-Дата('00010101'));
		//	КаталогРаспаковки=_КаталогВременныхФайлов()+ФайлДляРаспаковки.Имя+Строка(ГСЧ.СлучайноеЧисло(0, 1000)) +".und";
		//Иначе
		//	КаталогРаспаковки=_КаталогВременныхФайлов()+ФайлДляРаспаковки.Имя+".und";
		//КонецЕсли;
		КаталогРаспаковки = КаталогРабочихФайлов()+ (Новый УникальныйИдентификатор()) +".und";
	ИначеЕсли	НайтиФайлы(КаталогРаспаковки,"*.*").Количество()>0 тогда
		//Предупреждение("Указанный каталог не пустой. В каталоге будет создан подкаталог"+Символы.ПС+КаталогРаспаковки+"\"+ФайлДляРаспаковки.Имя+".und");
		//КаталогРаспаковки=КаталогРаспаковки+"\"+ФайлДляРаспаковки.Имя+".und";
	КонецЕсли;
	
	Если НЕ мКонтекстВыполнения.ФайлПрограммыРаспаковки.Существует() тогда
		ВывестиОшибку("Не существует файл программы распаковки <"+мКонтекстВыполнения.ФайлПрограммыРаспаковки.ПолноеИмя+">");
		Возврат Ложь;
	КонецЕсли;
	
	СтрокаЗапуска = """"+мКонтекстВыполнения.ФайлПрограммыРаспаковки.ПолноеИмя+""" -parse """+ФайлДляРаспаковки.ПолноеИмя+""" """+КаталогРаспаковки+"""";
	
	ЗапуститьПриложение(СтрокаЗапуска,,Истина);
	Возврат Истина;
КонецФункции

Функция Упаковка(ФайлРезультат,Каталог)
	каталогДляУпаковки=Новый файл(Каталог);
	
	Если НЕ мКонтекстВыполнения.ФайлПрограммыРаспаковки.Существует() тогда
		ВывестиОшибку("Не существует файл программы распаковки <"+мКонтекстВыполнения.ФайлПрограммыРаспаковки.ПолноеИмя+">");
		Возврат Ложь;
	КонецЕсли;
	
	СтрокаЗапуска = """"+мКонтекстВыполнения.ФайлПрограммыРаспаковки.ПолноеИмя+""" -build """+каталогДляУпаковки.ПолноеИмя+""" """+ФайлРезультат+"""";
	ВывестиОтладочноеСообщение(СтрокаЗапуска);
	
	ЗапуститьПриложение(СтрокаЗапуска,,Истина);
	
	Возврат Истина;
КонецФункции

Функция ПрочитатьТаблицуИсторииВерсий(Знач ПутьКХМЛФайлуВерсийХранилища1С)

	Перем ТаблицаИсторииХранилища;
	
	Если НЕ ПрочитатьФайлВерсийИзXML(ПутьКХМЛФайлуВерсийХранилища1С, таблицаИсторииХранилища) Тогда
		ВызватьИсключение "Не удалось получить таблицу версий из хранилища 1С - ПолучитьТаблицуВерсийИзФайлаХранилища1С";
	КонецЕсли;

	Возврат ТаблицаИсторииХранилища;
	
КонецФункции

Функция ПрочитатьТаблицуПользователейХранилища(Знач ПутьКХМЛФайлуПользователейХранилища1С)

	Перем ТаблицаПользователейХранилища;
	Если НЕ ПрочитатьФайлПользователей(ПутьКХМЛФайлуПользователейХранилища1С, ТаблицаПользователейХранилища) Тогда
		ВызватьИсключение "Не удалось получить таблицу пользователей из хранилища 1С - ПолучитьТаблицуВерсийИзФайлаХранилища1С";
	КонецЕсли; 
	
	Возврат ТаблицаПользователейХранилища;
	
КонецФункции

Функция ПрочитатьТаблицыХранилищаИзXML(резПутьКХМЛФайлуВерсийХранилища1С, резПутьКХМЛФайлуПользователейХранилища1С, резТаблицаИсторииХранилища, резТаблицаАвторовХранилища) Экспорт
	
	таблицаИсторииХранилища = ПрочитатьТаблицуИсторииВерсий(резПутьКХМЛФайлуВерсийХранилища1С);
	таблицаПользователейХранилища = ПрочитатьТаблицуПользователейХранилища(резПутьКХМЛФайлуПользователейХранилища1С);
	
	резТаблицаИсторииХранилища = Неопределено;
	резТаблицаАвторовХранилища = таблицаПользователейХранилища;
	
	успешно = Истина;
	Для каждого строка Из таблицаИсторииХранилища Цикл
		строкаПользователя = НайтиЗаписьВТаблице(таблицаПользователейХранилища,строка.ГУИД_Автора, "ГУИД_Автора");
		Если строкаПользователя = Неопределено Тогда
			Сообщение = "Не удалось найти автора коммита из хранилища 1С по номеру версии <%1>, комментарий <%2>, ГУИД-у <%3> - ПолучитьТаблицуВерсийИзФайлаХранилища1С";
			ВывестиОшибку(ПодставитьПараметрыВСтроку(Сообщение, строка.НомерВерсии, строка.Комментарий, строка.ГУИД_Автора));
		Иначе
			строка.Автор = строкаПользователя.Автор;
		КонецЕсли; 
	КонецЦикла; 
	резТаблицаИсторииХранилища = таблицаИсторииХранилища;
	
	Возврат успешно;
КонецФункции

Функция ПолучитьТаблицуВерсийИзФайлаХранилищаГит(КаталогВыгрузки, ПутьКФайлуХранилища1С, резТаблицаИсторииХранилища, резТаблицаАвторовХранилища, резТаблицаПользователейГит) Экспорт
	
	Перем резПутьКХМЛФайлуВерсийХранилища1С;
	Перем резПутьКХМЛФайлуПользователейХранилища1С;
	
	Если Не ВыгрузитьТаблицыВерсийИПользователейИзФайлаХранилища1С(ПутьКФайлуХранилища1С, резПутьКХМЛФайлуВерсийХранилища1С, резПутьКХМЛФайлуПользователейХранилища1С) Тогда
		ВывестиОшибку("Не удалось получить файлы таблиц из хранилища 1С - ПолучитьТаблицуВерсийИзФайлаХранилищаГит");
		Возврат Ложь;
	КонецЕсли; 
	
	Попытка
		ПрочитатьТаблицыХранилищаИзXML(
			резПутьКХМЛФайлуВерсийХранилища1С, 
			резПутьКХМЛФайлуПользователейХранилища1С,
			резТаблицаИсторииХранилища, // out
			резТаблицаАвторовХранилища); // out
	Исключение
		ВывестиОшибку(ИнформацияОбОшибке());
		Возврат Ложь;
	КонецПопытки;
	
	Если НЕ ПроверитьСуществованиеФайлаКаталога(КаталогВыгрузки, "путь к папке синхронизации") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	лПутьФайлаПользователей = КаталогВыгрузки+"\AUTHORS";
	
	таблицаПользователейГит = Неопределено;
	
	Если НЕ ПрочитатьФайлАвторовГит(лПутьФайлаПользователей, таблицаПользователейГит) Тогда
		ВывестиОшибку("Не удалось получить таблицу пользователей из гит 1С - ПолучитьТаблицуВерсийИзФайлаХранилищаГит");
		Возврат Ложь;
	КонецЕсли; 
	
	резТаблицаПользователейГит = таблицаПользователейГит;
	
	таблицаАвторовХранилища = резТаблицаАвторовХранилища;
	таблицаИсторииХранилища = резТаблицаИсторииХранилища;
	успешно = Истина;
	Для Каждого строка Из таблицаАвторовХранилища Цикл
		
		строкаПользователя = НайтиЗаписьВТаблице(таблицаПользователейГит, строка.Автор, "Автор");
		Если строкаПользователя = Неопределено Тогда
			СтрокаСообщения = "Пользователю хранилища <%1> не сопоставлен пользователь git. Использую сопоставление по умолчанию";
			ВывестиОтладочноеСообщение(ПодставитьПараметрыВСтроку(СтрокаСообщения, строка.Автор));
			ПредставлениеАвтора = ПодставитьПараметрыВСтроку("%1 <%1@%2>", строка.Автор, мПараметры.ДоменПочтыДляGit);
		Иначе
			ПредставлениеАвтора = строкаПользователя.ПредставлениеАвтора;
		КонецЕсли; 
		
		строка.ПредставлениеАвтора = ПредставлениеАвтора;
			
		НайденныеСтроки = НайтиСтрокиВТаблице(ТаблицаИсторииХранилища, строка.Автор, "Автор");
		Если НайденныеСтроки.Количество() > 0 Тогда
			Для каждого элементМассива Из НайденныеСтроки Цикл
				элементМассива.ПредставлениеАвтора = ПредставлениеАвтора;
			КонецЦикла;
		КонецЕсли; 
		
	КонецЦикла; 
		
	Возврат успешно;
КонецФункции

Функция ТребуетсяСинхронизироватьХранилищеСГит(Знач ФайлХранилища, Знач ЛокальныйКаталогГит) Экспорт
	
	КаталогТаблицХранилища = СоздатьВременныйКаталог();
	
	ПрочитатьХранилище(ФайлХранилища, "VERSIONS", КаталогТаблицХранилища);
	
	ФайлТаблицы = КаталогТаблицХранилища + "\versions.xml";
	
	ТаблицаВерсий = ПрочитатьТаблицуИсторииВерсий(ФайлТаблицы);
	ТекущаяВерсия = НомерСинхронизированнойВерсии(ЛокальныйКаталогГит);
	МаксимальнаяВерсияДляРазбора = ОпределитьМаксимальнуюВерсиюВХранилище(ТаблицаВерсий);
	
	ВывестиСообщение("Номер синхронизированной версии: " + ТекущаяВерсия);
	ВывестиСообщение("Номер последней версии в хранилище: " + МаксимальнаяВерсияДляРазбора);
	
	Возврат ТекущаяВерсия < МаксимальнаяВерсияДляРазбора;
	
КонецФункции

Функция СинхронизироватьХранилищеКонфигурацийСГит(СтруктураПараметров) Экспорт
	
	ТаблицаИсторииХранилища = Неопределено;
	ТаблицаАвторовХранилища = Неопределено;
	ТаблицаПользователейГит = Неопределено;
	
	Если НЕ ПолучитьТаблицуВерсийИзФайлаХранилищаГит(
			СтруктураПараметров.КаталогВыгрузки,
			СтруктураПараметров.ПутьКФайлуХранилища1С,
			ТаблицаИсторииХранилища, // out
			ТаблицаАвторовХранилища, // out
			ТаблицаПользователейГит // out
			) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если СтруктураПараметров.Свойство("МаксимальнаяВерсия") Тогда
		МаксимальнаяВерсия = СтруктураПараметров.МаксимальнаяВерсия;
	Иначе
		МаксимальнаяВерсия = 0;
	КонецЕсли;
	
	ТекущаяВерсия = НомерСинхронизированнойВерсии(СтруктураПараметров.КаталогВыгрузки);
	ВывестиСообщение("Номер синхронизированной версии: " + ТекущаяВерсия);
	СледующаяВерсия = ОпределитьПоследнуюСледующуюВерсиюАвтора(ТаблицаИсторииХранилища, ТекущаяВерсия);
	
	МаксимальнаяВерсияДляРазбора = ОпределитьМаксимальнуюВерсиюСУчетомПараметраМакс(ТаблицаИсторииХранилища, ТекущаяВерсия, МаксимальнаяВерсия);
	
	ВывестиСообщение("Номер последней версии в хранилище: " + МаксимальнаяВерсияДляРазбора); 
	
	успешно = Истина;
	
	Пока СледующаяВерсия <= МаксимальнаяВерсияДляРазбора Цикл
		лНачало = ТекущаяДата();
		ВывестиСообщение("Начало "+лНачало);
		
		СтрокаВерсии = ТаблицаИсторииХранилища.Найти(СледующаяВерсия, "НомерВерсии");
		Если СтрокаВерсии <> Неопределено Тогда
			
			Проверить(НЕ ПустаяСтрока(СтрокаВерсии.ПредставлениеАвтора), "Нашли следующую версию, а автор не прописан "+СледующаяВерсия + " автор "+СтрокаВерсии.Автор);
			
			ПутьКФайлуСинхронизацииВерсий = СтруктураПараметров.КаталогВыгрузки;
			успешно = ЗаписатьФайлВерсийГит(ПутьКФайлуСинхронизацииВерсий, СледующаяВерсия);
			Попытка
				Проверить(успешно, "Не удалось записать файл версии для "+ СледующаяВерсия);
				ВывестиСообщение("Получаем исходники для версии " + СледующаяВерсия);
				
				резПутьКФайлуКонфигурации = "";
				
				успешно = ВыгрузитьФайлыИзАрхива(СтруктураПараметров,ТекущаяВерсия + 1);
				
				Если НЕ успешно Тогда

					успешно = РазложитьМодули1СпоНомеруВерсииХранилища1С(
					"",// путь к базе, выполняющей команду 1С
					"",// версия платформы, выполняющей команду
					"",// пароль базы
					"",// пользователь базы
					СтруктураПараметров.ПутьКФайлуХранилища1С, 
					"",// пользователь хранилища
					"",// пароль хранилища 
					СтруктураПараметров.ПутьКФайлуХранилища1С,
					СледующаяВерсия, 
					СтруктураПараметров.КаталогВыгрузки,
					"", // каталог плоской выгрузки всех модулей 83
					резПутьКФайлуКонфигурации); // выходной параметр, который здесь игнорируется
				
					Проверить(успешно, "синхронизация с Git, версия <"+СледующаяВерсия+"> - не удалось выполнить РазложитьМодули1СпоНомеруВерсииХранилища1С");	
				КонецЕсли;
				
				
				
				Комментарий = СформироватьКомментарийСУчетомПромежуточныхВерсий(ТаблицаИсторииХранилища, ТекущаяВерсия, СледующаяВерсия);
				
				успешно = ВыполнитьКоммитГит(СтруктураПараметров.КаталогВыгрузки, Комментарий, СтрокаВерсии.ПредставлениеАвтора, СтрокаВерсии.Дата);
				
				Проверить(успешно, "синхронизация с Git, версия <"+СледующаяВерсия+"> - не удалось выполнить ВыполнитьКоммитГит");
				
			Исключение
				ОткатилисьУспешно = ЗаписатьФайлВерсийГит(ПутьКФайлуСинхронизацииВерсий, ТекущаяВерсия);
				Если Не ОткатилисьУспешно Тогда
					
					ТекОшибка = ОписаниеОшибки();
					ВызватьИсключение "Не удалось откатить файл VERSIONS после ошибки. Исходная ошибка:
					|	" + ТекОшибка;
					
				КонецЕсли;
				
				ВызватьИсключение;
			КонецПопытки;
			
			ТекущаяВерсия = СледующаяВерсия;			
		КонецЕсли;
		
		СледующаяВерсия = ОпределитьПоследнуюСледующуюВерсиюАвтора(ТаблицаИсторииХранилища, ТекущаяВерсия);
		
		лОкончание = ТекущаяДата();
		затратилиВремениВМинутах = (лОкончание - лНачало) / 60;
		ВывестиСообщение("Завершение "+лОкончание+ ", Общее время: "+затратилиВремениВМинутах+" мин.");
		
		Если ОсталосьОпераций() = 0 Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

Функция СохранитьВыгруженныеФайлыВАрхив(СтруктураПараметров) Экспорт
	
	ТаблицаИсторииХранилища = Неопределено;
	ТаблицаАвторовХранилища = Неопределено;
	ТаблицаПользователейГит = Неопределено;
	
	Если НЕ ПолучитьТаблицуВерсийИзФайлаХранилищаГит(
			СтруктураПараметров.КаталогВыгрузки,
			СтруктураПараметров.ПутьКФайлуХранилища1С,
			ТаблицаИсторииХранилища, // out
			ТаблицаАвторовХранилища, // out
			ТаблицаПользователейГит // out
			) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если СтруктураПараметров.Свойство("МаксимальнаяВерсия") Тогда
		МаксимальнаяВерсия = СтруктураПараметров.МаксимальнаяВерсия;
	Иначе
		МаксимальнаяВерсия = 0;
	КонецЕсли;
	
	ТекущаяВерсия = НомерСинхронизированнойВерсии(СтруктураПараметров.КаталогВыгрузки);
	ВывестиСообщение("Номер синхронизированной версии: " + ТекущаяВерсия);

	СледующаяВерсия = ОпределитьПоследнуюСледующуюВерсиюАвтора(ТаблицаИсторииХранилища, ТекущаяВерсия);
	
	МаксимальнаяВерсияДляРазбора = ОпределитьМаксимальнуюВерсиюСУчетомПараметраМакс(ТаблицаИсторииХранилища, ТекущаяВерсия, МаксимальнаяВерсия);
	
	ВывестиСообщение("Номер последней версии в хранилище: " + МаксимальнаяВерсияДляРазбора); 
	
	успешно = Истина;
	
	Пока СледующаяВерсия <= МаксимальнаяВерсияДляРазбора Цикл
	
		лНачало = ТекущаяДата();
		ВывестиСообщение("Начало "+лНачало);
		
		СтрокаВерсии = ТаблицаИсторииХранилища.Найти(СледующаяВерсия, "НомерВерсии");
		Если СтрокаВерсии <> Неопределено Тогда
	
			Проверить(НЕ ПустаяСтрока(СтрокаВерсии.ПредставлениеАвтора), "Нашли следующую версию, а автор не прописан "+СледующаяВерсия + " автор "+СтрокаВерсии.Автор);
			
			ПутьКФайлуСинхронизацииВерсий = СтруктураПараметров.КаталогВыгрузки;
			
			// проверим что файл еще не создан
			ФайлАрхиваСоздан = ПроверитьСуществованиеФайлаКаталога(СтруктураПараметров.ПутьСохраненияАрхивов +  "\" + (ТекущаяВерсия + 1) + ".zip");
			ФайлБлокировкиСоздан = ПроверитьСуществованиеФайлаКаталога(СтруктураПараметров.ПутьСохраненияАрхивов +  "\" + (ТекущаяВерсия + 1) + ".lock");
			
			Если НЕ (ФайлАрхиваСоздан ИЛИ ФайлБлокировкиСоздан) Тогда 
				Попытка					
					ВывестиСообщение("Получаем исходники для версии " + СледующаяВерсия);
					
					резПутьКФайлуКонфигурации = "";

					КаталогВыгрузки = СоздатьВременныйКаталог();
					
					СоздатьУникальныйФайл(СтруктураПараметров.ПутьСохраненияАрхивов +  "\" + (ТекущаяВерсия + 1) + ".lock");
					
					успешно = РазложитьМодули1СпоНомеруВерсииХранилища1С(
						"",// путь к базе, выполняющей команду 1С
						"",// версия платформы, выполняющей команду
						"",// пароль базы
						"",// пользователь базы
						СтруктураПараметров.ПутьКФайлуХранилища1С, 
						"",// пользователь хранилища
						"",// пароль хранилища 
						СтруктураПараметров.ПутьКФайлуХранилища1С,
						СледующаяВерсия,
						КаталогВыгрузки,
						"", // каталог плоской выгрузки всех модулей 83
						резПутьКФайлуКонфигурации); // выходной параметр, который здесь игнорируется
						
						Проверить(успешно, "синхронизация с Git, версия <"+СледующаяВерсия+"> - не удалось выполнить РазложитьМодули1СпоНомеруВерсииХранилища1С");	
					
				Исключение
					ОткатилисьУспешно = ЗаписатьФайлВерсийГит(ПутьКФайлуСинхронизацииВерсий, ТекущаяВерсия);
					Если Не ОткатилисьУспешно Тогда
						
						ТекОшибка = ОписаниеОшибки();
						ВызватьИсключение "Не удалось откатить файл VERSIONS после ошибки. Исходная ошибка:
						|	" + ТекОшибка;
						
					КонецЕсли;
					
					ВызватьИсключение;
				КонецПопытки;
			
				ДобавитьВыгруженныеФайлыВАрхив(СтруктураПараметров,КаталогВыгрузки,ТекущаяВерсия + 1);
				УдалитьФайлы(СтруктураПараметров.ПутьСохраненияАрхивов +  "\" + (ТекущаяВерсия + 1) + ".lock");
				
			КонецЕсли;
		
			ТекущаяВерсияВДанныйМомент = НомерСинхронизированнойВерсии(СтруктураПараметров.КаталогВыгрузки);
			Если ТекущаяВерсияВДанныйМомент = ТекущаяВерсия Тогда
				ТекущаяВерсия = СледующаяВерсия;
				успешно = ЗаписатьФайлВерсийГит(ПутьКФайлуСинхронизацииВерсий, ТекущаяВерсия);
				Проверить(успешно, "Не удалось записать файл версии для "+ ТекущаяВерсия);
			Иначе
				ТекущаяВерсия = ТекущаяВерсияВДанныйМомент;
			КонецЕсли;
			
			СледующаяВерсия = ОпределитьПоследнуюСледующуюВерсиюАвтора(ТаблицаИсторииХранилища, ТекущаяВерсия);
			
			лОкончание = ТекущаяДата();
			затратилиВремениВМинутах = (лОкончание - лНачало) / 60;
			ВывестиСообщение("Завершение "+лОкончание+ ", Общее время: "+затратилиВремениВМинутах+" мин.");
			
			Если ОсталосьОпераций() = 0 Тогда
				Возврат Истина;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции


Функция НомерСинхронизированнойВерсии(Знач КаталогВыгрузки)
	
	ПутьФайлаВерсий = КаталогВыгрузки+"\VERSION";
	
	ТекущаяВерсия = "";
	Если НЕ ПрочитатьФайлВерсийГит(ПутьФайлаВерсий, ТекущаяВерсия) Тогда
		ТекущаяВерсия = 0;
	КонецЕсли;

	Попытка
		ТекущаяВерсия=Число(ТекущаяВерсия);
	Исключение
		ТекущаяВерсия = 0;
	КонецПопытки;
	
	Возврат ТекущаяВерсия;
	
КонецФункции

// TODO: - выяснить сакральный смысл параметра МаксимальнаяВерсия у @sosnae
// Если он не нужен - удалить эту функцию.
Функция ОпределитьМаксимальнуюВерсиюСУчетомПараметраМакс(Знач ТаблицаИсторииХранилища, Знач ТекущаяВерсия, Знач МаксимальнаяВерсия)
	
	МаксимальнаяВерсияДляРазбора = 0;
	ЧислоВерсийПлюс = 0;

	Если МаксимальнаяВерсия <> 0 Тогда
		Попытка
			ЧислоВерсийПлюс = Число(МаксимальнаяВерсия);
		Исключение
			ЧислоВерсийПлюс = 0;
		КонецПопытки;
	КонецЕсли;
	
	Если ЧислоВерсийПлюс>0 Тогда
		МаксимальнаяВерсияДляРазбора = ТекущаяВерсия + ЧислоВерсийПлюс;
	Иначе
		МаксимальнаяВерсияДляРазбора = ОпределитьМаксимальнуюВерсиюВХранилище(ТаблицаИсторииХранилища);
	КонецЕсли;
	
	Возврат МаксимальнаяВерсияДляРазбора;
	
КонецФункции

Функция ОпределитьМаксимальнуюВерсиюВХранилище(Знач ТаблицаИсторииХранилища)
	
	МаксимальнаяВерсия = Число(ТаблицаИсторииХранилища[0].НомерВерсии);
	Для Сч = 1 По ТаблицаИсторииХранилища.Количество()-1 Цикл
		ЧислоВерсии = Число(ТаблицаИсторииХранилища[Сч].НомерВерсии);
		Если ЧислоВерсии > МаксимальнаяВерсия Тогда
			МаксимальнаяВерсия = ЧислоВерсии;
		КонецЕсли;
	КонецЦикла;
	
	Возврат МаксимальнаяВерсия;
	
КонецФункции

Функция УдалитьИгнорируемыеТипыФайлов(лПутьКаталогаВыгрузкиВсехМодулей83)
	М = Новый Массив;
	М.добавить("*.Form");
	М.добавить("*Template.xml");
	М.добавить("*.Interface");
	М.добавить("CommonPicture*");
	М.добавить("CommonTemplate*");

	для каждого Э из М Цикл
		УдалитьФайлы(лПутьКаталогаВыгрузкиВсехМодулей83, Э);
	КонецЦикла;
КонецФункции

Функция ОпределитьПоследнуюСледующуюВерсиюАвтора(Знач ТаблицаИсторииХранилища, Знач ТекущаяВерсия)
	СледующаяВерсия 	= ТекущаяВерсия + 1;
	
	Если РежимУплотнения() Тогда
		Если ТекущаяВерсия < ТаблицаИсторииХранилища.Количество() - 1 Тогда
			ТекущийГУИД_Автора = Строка(ТаблицаИсторииХранилища[ТекущаяВерсия].ГУИД_Автора);
			Для Сч = ТекущаяВерсия По ТаблицаИсторииХранилища.Количество() - 1 Цикл
				Если ТекущийГУИД_Автора = Строка(ТаблицаИсторииХранилища[Сч].ГУИД_Автора) Тогда
					СледующаяВерсия = Число(ТаблицаИсторииХранилища[Сч].НомерВерсии);
				КонецЕсли;	
				Если ТекущийГУИД_Автора <> Строка(ТаблицаИсторииХранилища[Сч].ГУИД_Автора) Тогда
					Возврат СледующаяВерсия;	
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	Возврат СледующаяВерсия;
КонецФункции

Функция СформироватьКомментарийСУчетомПромежуточныхВерсий(Знач ТаблицаИсторииХранилища, Знач ТекущаяВерсия, Знач СледующаяВерсия)
	НомераПромежуточныхВерсий = "";
	КомментарииПромежуточныхВерсий = "";
	Результат = "";
	Для Сч = ТекущаяВерсия По СледующаяВерсия - 1 Цикл
		НомераПромежуточныхВерсий	= НомераПромежуточныхВерсий + Строка(ТаблицаИсторииХранилища[Сч].НомерВерсии) + ";";
		Если ЗначениеЗаполнено(Строка(ТаблицаИсторииХранилища[Сч].Комментарий)) Тогда
			КомментарииПромежуточныхВерсий	= КомментарииПромежуточныхВерсий + " " + Строка(ТаблицаИсторииХранилища[Сч].НомерВерсии) + ":" + Строка(ТаблицаИсторииХранилища[Сч].Комментарий) + ";";
		КонецЕсли;
	КонецЦикла;
	
	Если (СледующаяВерсия - ТекущаяВерсия = 1) И ЗначениеЗаполнено(КомментарииПромежуточныхВерсий) Тогда
		Результат = КомментарииПромежуточныхВерсий;
	Иначе
		Результат = НомераПромежуточныхВерсий + " " + КомментарииПромежуточныхВерсий;
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

Функция ДобавитьВыгруженныеФайлыВАрхив(Знач СтруктураПараметров, Знач КаталогВыгрузки,Знач СледующаяВерсия)
	КомандныйФайл = СоздатьКомандныйФайл();
	СтрокаКоманды = ПодставитьПараметрыВСтроку("""%1"" a ""%2"" ""%3""", 
					СтруктураПараметров.ПутьZIP, 
					СтруктураПараметров.ПутьСохраненияАрхивов +  "\" + СледующаяВерсия + ".zip", 
					КаталогВыгрузки + "\*");
					
	ВывестиОтладочноеСообщение("Строка команды запуска архивации: " + СтрокаКоманды);
	ДобавитьВКомандныйФайл(КомандныйФайл, СтрокаКоманды);
	Результат = ВыполнитьКомандныйФайл(КомандныйФайл);
	
	Возврат Результат;
КонецФункции

Функция ВыгрузитьФайлыИзАрхива(Знач СтруктураПараметров,Знач СледующаяВерсия)
	
	Если Не ПроверитьСуществованиеФайлаКаталога(СтруктураПараметров.ПутьСохраненияАрхивов +  "\" + СледующаяВерсия + ".zip", "путь к архиву <"+СтруктураПараметров.ПутьСохраненияАрхивов +  "\" + СледующаяВерсия + ".zip"+">") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ОчиститьКаталогРаспаковки(СтруктураПараметров.КаталогВыгрузки);

	КомандныйФайл = СоздатьКомандныйФайл();
	СтрокаКоманды = ПодставитьПараметрыВСтроку("""%1"" x -y ""%2"" -o""%3""", 
					СтруктураПараметров.ПутьZIP, 
					СтруктураПараметров.ПутьСохраненияАрхивов +  "\" + СледующаяВерсия + ".zip", 
					СтруктураПараметров.КаталогВыгрузки + "\");
					
	ВывестиОтладочноеСообщение("Строка команды запуска архивации: " + СтрокаКоманды);
	ДобавитьВКомандныйФайл(КомандныйФайл, СтрокаКоманды);
	Результат = ВыполнитьКомандныйФайл(КомандныйФайл);
	
	Возврат Результат = 0;
КонецФункции

Функция ПутьTool1CD()
	ФайлTool1C = Новый Файл("vendors\tool1cd\cTool_1CD.exe");
	Возврат ФайлTool1C.ПолноеИмя;
КонецФункции

Процедура ПрочитатьХранилище(Знач ФайлХранилища, Знач ИменаТаблиц, Знач Каталог)

	СтрокаЗапуска = ОбернутьВКавычки(ПутьTool1CD())
			+ " " 
			+ ФайлХранилища
			+ " -q -ne -ex " 
			+ Каталог + " " + ИменаТаблиц;
			
	КодВозврата = "";
	ВывестиСообщение(СтрокаЗапуска);
	
	ЗапуститьПриложение(СтрокаЗапуска, "", Истина, КодВозврата);
	Если КодВозврата <> 0 Тогда
		ВызватьИсключение "Tool_1CD вернул код: " + КодВозврата;
	КонецЕсли;
	
	Поз = Найти(ИменаТаблиц,";");
	Если Поз > 0 Тогда
		ИмяТаблицы = Лев(ИменаТаблиц, Поз-1);
	Иначе
		ИмяТаблицы = ИменаТаблиц;
	КонецЕсли;
	
	Файл = Новый Файл(Каталог + "\" + ИмяТаблицы + ".xml");
	Если Не Файл.Существует() Тогда
		ВызватьИсключение "Tool_1CD не создал файлы";
	КонецЕсли;
	
КонецПроцедуры

Функция ВыгрузитьТаблицыВерсийИПользователейИзФайлаХранилища1С(ПутьКФайлуХранилища1С, резПутьКХМЛФайлуВерсийХранилища1С, резПутьКХМЛФайлуПользователейХранилища1С) Экспорт
	
	Если НЕ ПроверитьСуществованиеФайлаКаталога(ПутьКФайлуХранилища1С, "путь к файлу хранилища 1С") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ПутьКТаблицамИзФайлаХранилища1С = СоздатьВременныйКаталог()+"\";
	
	резПутьКХМЛФайлуВерсийХранилища1С = ПутьКТаблицамИзФайлаХранилища1С + "versions.xml";
	резПутьКХМЛФайлуПользователейХранилища1С = ПутьКТаблицамИзФайлаХранилища1С + "users.xml";
	
	ПрочитатьХранилище(ПутьКФайлуХранилища1С, "VERSIONS;USERS", ПутьКТаблицамИзФайлаХранилища1С);
	
	Если ПроверитьСуществованиеФайлаКаталога(резПутьКХМЛФайлуВерсийХранилища1С, "путь к файлу истории хранилища 1С")
		И ПроверитьСуществованиеФайлаКаталога(резПутьКХМЛФайлуПользователейХранилища1С, "путь к файлу пользователей хранилища 1С") Тогда
		ВывестиОтладочноеСообщение("Файлы выгружены из хранилища: " + ПутьКТаблицамИзФайлаХранилища1С);
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
КонецФункции

Функция ПрочитатьФайлПользователей(Знач парамПутьФайлаПользователей, таблицаПользователейХранилища = Неопределено)
	Если НЕ ЗначениеЗаполнено(парамПутьФайлаПользователей) Тогда
		таблицаПользователейХранилища = Неопределено;
		Возврат Ложь;
	КонецЕсли;
	
	Пользователи = Новый Массив;
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.ОткрытьФайл(парамПутьФайлаПользователей);
	
	Пока ЧтениеXML.Прочитать() Цикл 
		
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента 
			И ЧтениеXML.Имя = "Record" Тогда
			
			НоваяСтрока = НоваяЗаписьТаблицыПользователей(Пользователи);
			Пока ЧтениеXML.Прочитать() Цикл
				Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
					Если ЧтениеXML.Имя="USERID" Тогда
						НоваяСтрока.ГУИД_Автора = ПолучитьТекст(ЧтениеXML);
					КонецЕсли;
					Если ЧтениеXML.Имя="NAME" Тогда
						НоваяСтрока.Автор = ПолучитьТекст(ЧтениеXML);
					КонецЕсли;
				КонецЕсли;
				
				Если ЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента И ЧтениеXML.Имя = "Record" Тогда
					Прервать;	
				КонецЕсли;
			
			КонецЦикла;	
				
		КонецЕсли;
	
	КонецЦикла;
	
	ЧтениеXML.Закрыть();
	таблицаПользователейХранилища = Пользователи;

	Возврат Истина;
КонецФункции

Функция НоваяЗаписьТаблицыПользователей(Знач ТаблицаПользователей)

	СтруктураПолей = Новый Структура;
	СтруктураПолей.Вставить("Автор");
	СтруктураПолей.Вставить("ГУИД_Автора");
	СтруктураПолей.Вставить("ПредставлениеАвтора");
	
	ТаблицаПользователей.Добавить(СтруктураПолей);
	
	Возврат СтруктураПолей;

КонецФункции
 
Функция НоваяТаблицаИсторииВерсий()

	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("НомерВерсии");
	Таблица.Колонки.Добавить("ГУИД_Автора");
	Таблица.Колонки.Добавить("Автор");
	Таблица.Колонки.Добавить("Тэг");
	Таблица.Колонки.Добавить("Дата");
	Таблица.Колонки.Добавить("Комментарий");
	Таблица.Колонки.Добавить("ПредставлениеАвтора");
	
	Возврат Таблица;

КонецФункции 
 
Функция ПрочитатьФайлВерсийИзXML(Знач парамПутьКФайлуВерсий, таблицаИсторииХранилища = Неопределено) //Экспорт
	Если НЕ ЗначениеЗаполнено(парамПутьКФайлуВерсий) Тогда
		таблицаИсторииХранилища = Неопределено;
		Возврат Ложь;
	КонецЕсли;
	
	История = НоваяТаблицаИсторииВерсий();
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.ОткрытьФайл(парамПутьКФайлуВерсий);
	
	Пока ЧтениеXML.Прочитать() Цикл 
		
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента 
			И ЧтениеXML.Имя = "Record" Тогда
			
			НоваяСтрока = История.Добавить();
			Пока ЧтениеXML.Прочитать() Цикл
				Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
					Если ЧтениеXML.Имя="VERNUM" Тогда
						НоваяСтрока.НомерВерсии = Число(ПолучитьТекст(ЧтениеXML));
					КонецЕсли;
					Если ЧтениеXML.Имя="USERID" Тогда
						НоваяСтрока.ГУИД_Автора = ПолучитьТекст(ЧтениеXML); //Автор
					КонецЕсли;
					Если ЧтениеXML.Имя="CODE" Тогда
						НоваяСтрока.Тэг = ПолучитьТекст(ЧтениеXML);
					КонецЕсли;
					Если ЧтениеXML.Имя="VERDATE" Тогда
						Дата = ПолучитьТекст(ЧтениеXML);
						Дата = СтрЗаменить(СтрЗаменить(Дата, "-", ""), ":", "");
						Дата = СтрЗаменить(Дата, "T", "");
						Дата = Дата(Дата);
						НоваяСтрока.Дата = Дата;
					КонецЕсли;
					
					Если ЧтениеXML.Имя="COMMENT"  Тогда
						НоваяСтрока.Комментарий = ПолучитьТекст(ЧтениеXML);
					КонецЕсли;
					
					Если Ложь 
						ИЛИ 
						( Ложь
							ИЛИ ЧтениеXML.Имя = "SNAPSHOTMAKER"  
							ИЛИ ЧтениеXML.Имя = "SNAPSHOTCRC"
							ИЛИ ЧтениеXML.Имя = "PVERSION"
							ИЛИ ЧтениеXML.Имя = "CVERSION"
 
						)	Тогда
						Текст = ПолучитьТекст(ЧтениеXML);
					КонецЕсли;
					
					
					
				КонецЕсли;
				
				Если ЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента И ЧтениеXML.Имя = "Record" Тогда
					Прервать;	
				КонецЕсли;
			
			КонецЦикла;	
				
		КонецЕсли;
	
	КонецЦикла;

	ЧтениеXML.Закрыть();
	таблицаИсторииХранилища = История;
	
	Возврат Истина;
КонецФункции

Функция ПрочитатьФайлВерсийГит(парамПутьКФайлуВерсий, Версия = "", ЗаписыватьПустой = Ложь)
	 Перем лРезультат;
	
	 лРезультат = Ложь;
	 Если НЕ ЗначениеЗаполнено(парамПутьКФайлуВерсий) Тогда
		
		 Версия = "";
		 Возврат лРезультат;
	 КонецЕсли;
	
	 ПроверитьСуществованиеФайлаКаталога(парамПутьКФайлуВерсий, "Файл с версией ГИТ <"+парамПутьКФайлуВерсий+"> не существует - Синхронизация хранилища");	
	
	 ЧтениеXML = Новый ЧтениеXML;
	 ЧтениеXML.ОткрытьФайл(парамПутьКФайлуВерсий);
	
	 Пока ЧтениеXML.Прочитать() Цикл 
		 Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента И ЧтениеXML.Имя = "VERSION" Тогда 
			 
			 Проверить(ЧтениеXML.Прочитать(), "Чтение файла версий, у элемента Version нет текста - Синхронизация хранилища");
			 Проверить(ЧтениеXML.ТипУзла = ТипУзлаXML.Текст, "Чтение файла версий, у элемента Version нет текста - Синхронизация хранилища");
			 
			 Версия = ЧтениеXML.Значение;
			 ВывестиОтладочноеСообщение("  Предыдущая версия из хранилища 1С: "+Версия);
			 
			 лРезультат = Истина;
			 Прервать;
		 КонецЕсли;
		
	 КонецЦикла;
	
	 ЧтениеXML.Закрыть();
	
	 Возврат лРезультат;
	
КонецФункции

Функция НайтиЗаписьВТаблице(Знач Таблица, Знач ИскомоеЗначение, Знач Колонка)

	Перем Результат;
	Для Каждого Стр Из Таблица Цикл
		Если Стр[Колонка] = ИскомоеЗначение Тогда
			Результат = Стр;
			Прервать;
		КонецЕсли;
	КонецЦикла;

	Возврат Результат;
	
КонецФункции

Функция НайтиСтрокиВТаблице(Знач Таблица, Знач ИскомоеЗначение, Знач Колонка)
	
	НайденныеСтроки = Новый Массив;
	
	Для Каждого Стр Из Таблица Цикл
		Если Стр[Колонка] = ИскомоеЗначение Тогда
			НайденныеСтроки.Добавить(Стр);
		КонецЕсли;
	КонецЦикла;
	
	Возврат НайденныеСтроки;
	
КонецФункции

Функция ЗаписатьФайлВерсийГит(Знач КаталогФайлаВерсий, Знач Версия = "") Экспорт 
	
	Результат = Истина;
	ПутьКФайлуВерсий = КаталогФайлаВерсий + "\VERSION";
	ВывестиОтладочноеСообщение("ПутьКФайлуВерсий =<"+ПутьКФайлуВерсий+">");
	Попытка
		Запись = Новый ЗаписьТекста(ПутьКФайлуВерсий, "utf-8");
		Запись.ЗаписатьСтроку("<?xml version=""1.0"" encoding=""UTF-8""?>");
		Запись.ЗаписатьСтроку("<VERSION>" + Версия + "</VERSION>");
		Запись.Закрыть();
	Исключение
		Если Запись <> Неопределено Тогда
			ОсвободитьОбъект(Запись);
		КонецЕсли;
		ВывестиСообщение(ИнформацияОбОшибке().ПодробноеОписаниеОшибки());
		Результат = Ложь;
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

Функция ПрочитатьФайлАвторовГит(парамПутьКФайлуАвторов, ТаблицаПользователей =  Неопределено)
	Перем лРезультат;

	лРезультат = Ложь;
	Если НЕ ЗначениеЗаполнено(парамПутьКФайлуАвторов) Тогда
		ТаблицаПользователей = Неопределено;
		Возврат лРезультат;
	КонецЕсли;

	Файл = Новый Файл(парамПутьКФайлуАвторов);
	Если Не Файл.Существует() Тогда
		ТаблицаПользователей = Новый Массив;
		Возврат Истина;
	КонецЕсли;

	Пользователи = Новый Массив;

	Попытка	
		ТекстовыйФайл = Новый ЧтениеТекста(парамПутьКФайлуАвторов,"utf-8");
		СтрокаФайла = "";
		Пока СтрокаФайла <> Неопределено Цикл
			СтрокаФайла = ТекстовыйФайл.ПрочитатьСтроку();
			Индекс = Найти(СтрокаФайла, "=");
			Если Индекс > 0 Тогда
				
				Ключ = Лев(СтрокаФайла, Индекс-1);
				АвторПредставление = Сред(СтрокаФайла, Индекс+1);
				
				НоваяСтрока = НоваяЗаписьТаблицыПользователей(Пользователи);
				НоваяСтрока.ПредставлениеАвтора = АвторПредставление;
				НоваяСтрока.Автор = Ключ;
			КонецЕсли;
		КонецЦикла;
		
		лРезультат = Истина;
	Исключение
		Если ТекстовыйФайл <> Неопределено Тогда
			ОсвободитьОбъект(ТекстовыйФайл);
		КонецЕсли;
		лРезультат = Ложь;
		ВывестиОшибку(ОписаниеОшибки());
	КонецПопытки;
	
	Если ТекстовыйФайл <> Неопределено Тогда
		ОсвободитьОбъект(ТекстовыйФайл);
	КонецЕсли;
	
	ТаблицаПользователей = Пользователи;

	Возврат лРезультат;
		 
КонецФункции

Функция ПолучитьТекст(ЧтениеXML)
	Результат = "";
	Пока ЧтениеXML.Прочитать()	Цикл
		
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
			Результат = ЧтениеXML.Значение;
		КонецЕсли;
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;  
	
	Возврат Результат;
	
КонецФункции

Функция ПоНомеруВерсииСохранитьКонфигурациюИзХранилища1СИзБазыХранилища(ПутьКФайлуХранилища1С, НомерВерсииХранилища, резПутьКФайлуКонфигурации) Экспорт
	
	Перем ИмяФайлаВыгрузкиКаталог, ПутьКБазе;
	
	резПутьКФайлуКонфигурации = "";
	
	Инициализация(ПолучитьПараметрыИнициализации());
	
	лИмяФайлаВыгрузкиКаталог = СоздатьВременныйКаталог();
	
	путьTool_1CD = ОбернутьВКавычки(ПутьTool1CD());
	
	лПутьФайлаВыгрузки = лИмяФайлаВыгрузкиКаталог+"\v"+Строка(НомерВерсииХранилища) +".cf";
	СтрокаЗапуска = путьTool_1CD + " """ + ПутьКФайлуХранилища1С + """ -q -ne -drc " + Строка(НомерВерсииХранилища) +" """ + лПутьФайлаВыгрузки +"""";
	ВывестиСообщение(СтрокаЗапуска);
	
	ЗапуститьПриложение(СтрокаЗапуска, лИмяФайлаВыгрузкиКаталог, Истина);
	
	ВыбФайл = Новый Файл(лПутьФайлаВыгрузки);	
	
	успешно = ВыбФайл.Существует();
	Если успешно Тогда
		резПутьКФайлуКонфигурации = ВыбФайл.ПолноеИмя;
	Иначе 
		ВывестиОшибку("Не удалось получить файл конфигурации по версии <"+НомерВерсииХранилища+"> из файла хранилища <"+ПутьКФайлуХранилища1С+">");
	КонецЕсли;
	
	Возврат успешно;		
КонецФункции

Функция ПоНомеруВерсииСохранитьКонфигурациюИзХранилища1С(
			ПутьКБазе,
			версияПлатформыДляБазы,
			Пользователь,
			Пароль,
			ПутьКХранилищу1C,
			ПользовательХранилища,
			ПарольХранилища, 
			ПутьКФайлуХранилища1С,
			НомерВерсииХранилища,
			резПутьКФайлуКонфигурации) Экспорт
	
	Перем ИмяФайлаВыгрузкиКаталог, лПутьКБазе;
	
	резПутьКФайлуКонфигурации = "";
	
	Параметры = ПолучитьПараметрыИнициализации();
	Инициализация(Параметры);
		
	ФайлХранилища = Новый Файл(ПутьКФайлуХранилища1С);
	Если ФайлХранилища.Существует() И ФайлХранилища.ЭтоФайл() И Найти(ВРег(ФайлХранилища.Расширение), "1CD") > 0 Тогда
		успешно = ПоНомеруВерсииСохранитьКонфигурациюИзХранилища1СИзБазыХранилища(ПутьКФайлуХранилища1С, НомерВерсииХранилища, резПутьКФайлуКонфигурации);
		Возврат успешно;
	КонецЕсли;
	
	
	ИмяФайлаВыгрузкиКаталог = СоздатьВременныйКаталог();

	ИмяФайлаКонфигурации = ИмяФайлаВыгрузкиКаталог + "1cv8_"
			+ "_" + Строка(НомерВерсииХранилища) + ".cf";
			
	ВыбФайл = Новый Файл(ИмяФайлаКонфигурации);
	Если ВыбФайл.Существует() Тогда
		УдалитьФайлы(ИмяФайлаКонфигурации);
	КонецЕсли;
	
	ВыбФайл = Неопределено;

	Если ПустаяСтрока(ПутьКБазе) Тогда
		СоздатьПустуюБазу("", ПутьКБазе);
	КонецЕсли;
	
	путьКПлатформе1С = ПолучитьПутьКВерсииПлатформы(версияПлатформыДляБазы);
	СтрокаЛогина = ПолучитьСтрокуЛогинаКомандыЗапуска1С(Пользователь, Пароль);
	
	АппЛог = ПолучитьВременноеИмяФайлаЛога();
	
	СтрокаХранилища = " /ConfigurationRepositoryF """+ПутьКХранилищу1C+"""";
	
	Если ЗначениеЗаполнено(ПользовательХранилища) Тогда
		СтрокаЛогинаХранилища = " /ConfigurationRepositoryN "+ПользовательХранилища 
							+ " /ConfigurationRepositoryP """+ПарольХранилища+"""";
	КонецЕсли;
	
	// выполняем
	Команда = """"+путьКПлатформе1С+""""
			+ " DESIGNER" + лПутьКБазе
			+ СтрокаЛогина
			+ СтрокаХранилища 
			+ СтрокаЛогинаХранилища
			+ " /ConfigurationRepositoryDumpCfg """ + ИмяФайлаКонфигурации+""""
			+ " -v "+Строка(НомерВерсииХранилища)
			+ " /DumpResult " +АппЛог
			+ " /Lru"
			"""";

	ВывестиСообщение(Команда);

	ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(Команда);
	
	ВыбФайл = Новый Файл(ИмяФайлаКонфигурации);
	успешно = ВыбФайл.Существует();
	Если успешно Тогда
		резПутьКФайлуКонфигурации = ИмяФайлаКонфигурации;
	КонецЕсли;
	
	БезопасноУдалитьВременныйФайл(АппЛог);
	
	Возврат успешно;
	
КонецФункции

Функция ПоНомеруВерсииРазобратьКонфигурациюИзХранилища1С(ПутьКБазе, версияПлатформыДляБазы, Пользователь, Пароль, ПутьКХранилищу1C, 
		ПользовательХранилища, ПарольХранилища, ПутьКФайлуХранилища1С, НомерВерсииХранилища, КаталогВыгрузкиВсехМодулей83, КаталогВыгрузки, 
		резПутьКФайлуКонфигурации) Экспорт
		
	резПутьКФайлуКонфигурации = "";
	Если НЕ ПоНомеруВерсииСохранитьКонфигурациюИзХранилища1С(ПутьКБазе, версияПлатформыДляБазы, Пользователь, Пароль, ПутьКХранилищу1C, 
		ПользовательХранилища, ПарольХранилища, ПутьКФайлуХранилища1С, НомерВерсииХранилища, резПутьКФайлуКонфигурации) Тогда
			Возврат Ложь;
	КонецЕсли;
	
	Если НЕ РазложитьМодули1СПоПапкамСогласноИерархииМетаданных(КаталогВыгрузкиВсехМодулей83, КаталогВыгрузки) Тогда
		Возврат Ложь;
	КонецЕсли; 
	
	Возврат Истина;
КонецФункции
 
Функция ПроверитьСуществованиеФайлаКаталога(парамПуть, допСообщениеОшибки = "")
	Если Не ЗначениеЗаполнено(парамПуть) Тогда
		ВывестиОшибку("Не указан путь <"+допСообщениеОшибки+">");
		Возврат Ложь;
	КонецЕсли;
	
	лфайл = Новый Файл(парамПуть);
	Если Не лфайл.Существует() Тогда
		ВывестиОшибку("Не существует файл <"+допСообщениеОшибки+"> " + парамПуть);
		Возврат Ложь;	
	КонецЕсли;
	
	Возврат Истина;
КонецФункции

Функция ВыполнитьGitPush(Знач ЛокальныйРепозиторий, Знач УдаленныйРепозиторий, Знач ИмяВетки) Экспорт

	КомандныйФайл = СоздатьКомандныйФайл();
	ИмяФайлаЛогаКоммита = СоздатьВременныйФайл("log");
	
	ДобавитьВКомандныйФайл(КомандныйФайл, ПодставитьПараметрыВСтроку("cd /d ""%1""", ЛокальныйРепозиторий));
	ДобавитьВКомандныйФайл(КомандныйФайл, "set gitpath=" + ОбернутьВКавычки(мПараметры.ПутьGit));
	ДобавитьВКомандныйФайл(КомандныйФайл, "%gitpath% gc --auto");
	
	ПараметрыКоманды = Новый Массив;
	ПараметрыКоманды.Добавить("%gitpath% push -u");
	ПараметрыКоманды.Добавить(СтрЗаменить(УдаленныйРепозиторий, "%", "%%"));
	ПараметрыКоманды.Добавить("--all -v");
	ПараметрыКоманды.Добавить(СуффиксПеренаправленияВывода(ИмяФайлаЛогаКоммита, Истина));
	
	СтрокаКоманды = СобратьКоманднуюСтроку(ПараметрыКоманды);
	сообщение = "строкаКоманды = <"+?(строкаКоманды = Неопределено, "Неопределено", строкаКоманды)+">";
	ВывестиСообщение(сообщение);
	ДобавитьВКомандныйФайл(КомандныйФайл, СтрокаКоманды);
	ДобавитьВКомандныйФайл(КомандныйФайл, "exit /b %ERRORLEVEL%");
	
	Результат = ВыполнитьКомандныйФайл(КомандныйФайл);
	ВывестиТекстФайла(ИмяФайлаЛогаКоммита);
	ЗавершитьПроцесс_TGitCache_exe();
	
	Возврат Результат;
	
КонецФункции
 
Функция ВыполнитьGitPull(Знач ЛокальныйРепозиторий, Знач УдаленныйРепозиторий, Знач ИмяВетки) Экспорт

	КомандныйФайл = СоздатьКомандныйФайл();
	ИмяФайлаЛогаКоммита = СоздатьВременныйФайл("log");
	
	ДобавитьВКомандныйФайл(КомандныйФайл, ПодставитьПараметрыВСтроку("cd /d ""%1""", ЛокальныйРепозиторий));
	ДобавитьВКомандныйФайл(КомандныйФайл, "set gitpath=" + ОбернутьВКавычки(мПараметры.ПутьGit));
	
	ПараметрыКоманды = Новый Массив;
	ПараметрыКоманды.Добавить("%gitpath% pull");
	ПараметрыКоманды.Добавить("-v");
	ПараметрыКоманды.Добавить(СтрЗаменить(УдаленныйРепозиторий, "%", "%%"));
	ПараметрыКоманды.Добавить(СуффиксПеренаправленияВывода(ИмяФайлаЛогаКоммита, Истина));
	
	СтрокаКоманды = СобратьКоманднуюСтроку(ПараметрыКоманды);
	сообщение = "строкаКоманды = <"+?(строкаКоманды = Неопределено, "Неопределено", строкаКоманды)+">";
	ВывестиСообщение(сообщение);
	
	ДобавитьВКомандныйФайл(КомандныйФайл, "%gitpath% fetch " + УдаленныйРепозиторий);
	ДобавитьВКомандныйФайл(КомандныйФайл, "%gitpath% checkout origin/" + ИмяВетки + " -t");
	ДобавитьВКомандныйФайл(КомандныйФайл, "%gitpath% checkout " + ИмяВетки + "");
	ДобавитьВКомандныйФайл(КомандныйФайл, СтрокаКоманды);
	ДобавитьВКомандныйФайл(КомандныйФайл, "exit /b %ERRORLEVEL%");
	
	Результат = ВыполнитьКомандныйФайл(КомандныйФайл);
	ВывестиТекстФайла(ИмяФайлаЛогаКоммита);
	
	Возврат Результат;

КонецФункции
 
Функция СоздатьПустуюБазу(ПутьКФайлуКонфигурации = "", резИмяКаталогаБазы = "") //Экспорт //СтруктураПараметров
	Перем ИмяФайлаВыгрузкиКаталог, строкаПутьКБазе;
	Перем СоздаемБазуПоФайлуКонфигурации, СтрокаПроверкиОшибки;

	резИмяКаталогаБазы = "";
	
	ВывестиОтладочноеСообщение("Начало создать базу "+ТекущаяДата());
	Если НЕ ПроверитьСуществованиеФайлаКаталога(мПараметры.ПутьКПлатформе83, "путь к платформе 1С 8.3") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	БылаОшибка = Ложь;
	
	ПутьКВременномуКаталогуВыгрузки = СоздатьВременныйКаталог();
	ИмяКаталогаБазы = ПолучитьПутьКНовойБазе1С(ПутьКВременномуКаталогуВыгрузки);
	ЗарегистрироватьВременныйФайл(ИмяКаталогаБазы);
	
	ВывестиОтладочноеСообщение("Каталог временной базы: " + ИмяКаталогаБазы);
	
	Если Не ПроверитьСуществованиеФайлаКаталога(ИмяКаталогаБазы, "путь к новой базе <"+ИмяКаталогаБазы+">") Тогда
		Возврат Ложь;
	КонецЕсли; 
	
	АппЛог = ПолучитьВременноеИмяФайлаЛога();
	
	//выполняем
	Команда = """"+мПараметры.ПутьКПлатформе83+""""
			+ " CREATEINFOBASE  File=""" + ИмяКаталогаБазы+""""
			+ " /Lru"
			+ " /Out """+АппЛог+"""";
			
	СоздаемБазуПоФайлуКонфигурации = Не ПустаяСтрока(ПутьКФайлуКонфигурации); //Истина;
	
	Если СоздаемБазуПоФайлуКонфигурации Тогда
		СоздатьКаталог(ИмяКаталогаБазы);
		
		Команда = """"+мПараметры.ПутьКПлатформе83+""""
			+ " CREATEINFOBASE  File=""" + ИмяКаталогаБазы+""""
			+ " /Lru"
			+ " /Out """+АппЛог+"""";
			
	КонецЕсли;
			
	ВывестиСообщение(Команда);
	КодВозврата =  ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(Команда);
	Если КодВозврата <> 0 Тогда
		Сообщить("1С: " + КодВозврата);
	КонецЕсли;
	
	СтрокаПроверкиОшибки = "успешно завершено";
	
	Если СоздаемБазуПоФайлуКонфигурации Тогда		
		
		СписокСтрок = Новый Массив;
		СписокСтрок.Добавить(СтрокаПроверкиОшибки);	
		
		БылаОшибка = ПроверитьФайлНаОтсутствиеСтрок(АппЛог, СписокСтрок);
		
		Если БылаОшибка Тогда
			Возврат Ложь; //НЕ БылаОшибка;
		КонецЕсли;
		
		
		Команда = """"+мПараметры.ПутьКПлатформе83+"""" 
				+ " DESIGNER "+ПолучитьПодстрокуКомандыЗапуска1С_БазаДанных(ИмяКаталогаБазы)
				+ " /LoadCfg"""+ПутьКФайлуКонфигурации+""""
				+ " /Lru"
				+ " /Out """+АппЛог+"""";
				
		ВывестиСообщение(Команда);
		ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(Команда);
		
		СтрокаПроверкиОшибки = "успешно завершена";
		
	КонецЕсли;
	
	СписокСтрок = Новый Массив;
	СписокСтрок.Добавить(СтрокаПроверкиОшибки);	
	БылаОшибка = ПроверитьФайлНаОтсутствиеСтрок(АппЛог, СписокСтрок);
	Если Не БылаОшибка Тогда
		резИмяКаталогаБазы = ИмяКаталогаБазы;
		БезопасноУдалитьВременныйФайл(АппЛог);
	КонецЕсли;	
	
	ВывестиОтладочноеСообщение("Завершение: создать базу "+ТекущаяДата());
	Возврат НЕ БылаОшибка;

КонецФункции

Функция СохранитьКонфигурациюИзБазы(ПутьКФайлуКонфигурации, ИмяКаталогаБазы) //Экспорт
	Перем ИмяФайлаВыгрузкиКаталог, строкаПутьКБазе;
	
	ОптимизацияСоздания = Истина;
	ВывестиОтладочноеСообщение("Начало выгрузка базы "+ТекущаяДата());
	
	лфайл = Новый Файл(ПутьКФайлуКонфигурации);
	Если лфайл.Существует() Тогда
		Попытка
			УдалитьФайлы(ПутьКФайлуКонфигурации);
		Исключение
		КонецПопытки;
	КонецЕсли;
	
	БылаОшибка = Ложь;

	Если Не ПроверитьСуществованиеФайлаКаталога(ИмяКаталогаБазы, "путь к новой базе <"+ИмяКаталогаБазы+">") Тогда
		Возврат Ложь;
	КонецЕсли; 
	
	АппЛог = ПолучитьВременноеИмяФайлаЛога();

	Команда = """"+мПараметры.ПутьКПлатформе83+"""" 
			+ " DESIGNER "+ПолучитьПодстрокуКомандыЗапуска1С_БазаДанных(ИмяКаталогаБазы)
			+ " /DumpCfg"""+ПутьКФайлуКонфигурации+""""
			+ " /Lru"
			+ " /Out"""+АппЛог+"""";
			
	ВывестиСообщение(Команда);
	ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(Команда);
	
	СтрокаПроверкиОшибки = "Сохранение конфигурации успешно завершено";
	
	СписокСтрок = Новый Массив;
	СписокСтрок.Добавить(СтрокаПроверкиОшибки);	
	БылаОшибка = ПроверитьФайлНаОтсутствиеСтрок(АппЛог, СписокСтрок);
	
	Если Не БылаОшибка Тогда
		лфайл = Новый Файл(ПутьКФайлуКонфигурации);
		Если НЕ лфайл.Существует() Тогда
			БылаОшибка = Истина;
			ВывестиСообщение("Не существует итоговый файл конфигурации");
		КонецЕсли;
		 
		БезопасноУдалитьВременныйФайл(АппЛог);

	КонецЕсли;
	
	ВывестиОтладочноеСообщение("Завершение: выгрузка конфигурации "+ТекущаяДата());
	Возврат НЕ БылаОшибка;

КонецФункции


Функция СоздатьПустуюБазуБезШаблона(СтруктураПараметров) //Экспорт
	Перем ИмяФайлаВыгрузкиКаталог, строкаПутьКБазе;
	Перем СтрокаПроверкиОшибки; //ОптимизацияСоздания;

	ВывестиОтладочноеСообщение("Начало создать базу "+ТекущаяДата());
	Если НЕ ПроверитьСуществованиеФайлаКаталога(мПараметры.ПутьКПлатформе83, "путь к платформе 1С 8.3") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	БылаОшибка = Ложь;
	
	ПутьКВременномуКаталогуВыгрузки = СоздатьВременныйКаталог();
	ИмяКаталогаБазы = ПолучитьПутьКНовойБазе1С(ПутьКВременномуКаталогуВыгрузки);
	ЗарегистрироватьВременныйФайл(ИмяКаталогаБазы);

	Если Не ПроверитьСуществованиеФайлаКаталога(ИмяКаталогаБазы, "путь к новой базе <"+ИмяКаталогаБазы+">") Тогда
		Возврат Ложь;
	КонецЕсли; 
	
	АппЛог = ПолучитьВременноеИмяФайлаЛога();
	
	СоздатьКаталог(ИмяКаталогаБазы);
	Команда = """"+мПараметры.ПутьКПлатформе83+""""
		+ " CREATEINFOBASE  File=""" + ИмяКаталогаБазы+""""
		+ " /Lru"
		+ " /Out """+АппЛог+"""";
	
	ВывестиСообщение(Команда);
	ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(Команда);
	
	СтрокаПроверкиОшибки = "успешно завершено";
	
	СписокСтрок = Новый Массив;
	СписокСтрок.Добавить(СтрокаПроверкиОшибки);	
	БылаОшибка = ПроверитьФайлНаОтсутствиеСтрок(АппЛог, СписокСтрок);
	Если Не БылаОшибка Тогда
		СтруктураПараметров.Вставить("ИмяКаталогаБазы", ИмяКаталогаБазы);
		БезопасноУдалитьВременныйФайл(АппЛог);

	КонецЕсли;
	
	ВывестиОтладочноеСообщение("Завершение: создать базу "+ТекущаяДата());
	Возврат НЕ БылаОшибка;

КонецФункции

Функция ВыгрузитьМодули(ИмяКаталогаБазы, Пользователь, Пароль, резКаталогВыгрузкиВсехМодулей83) //Экспорт
	резКаталогВыгрузкиВсехМодулей83 = "";
	
	Если НЕ ПроверитьСуществованиеФайлаКаталога(мПараметры.ПутьКПлатформе83, "путь к платформе 1С 8.3") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Не ПроверитьСуществованиеФайлаКаталога(ИмяКаталогаБазы, "новая база") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ПутьКаталогаВыгрузкиДанных = СоздатьВременныйКаталог();
	
	файлВыгрузкиКаталог = Новый Файл(ПутьКаталогаВыгрузкиДанных);
	Если НЕ файлВыгрузкиКаталог.Существует() Тогда
		СоздатьКаталог(ПутьКаталогаВыгрузкиДанных);
		
		Проверить(файлВыгрузкиКаталог.Существует(), "Не существует каталог <"+ПутьКаталогаВыгрузкиДанных+">. Выполнение остановлено!");
	КонецЕсли;
	
	МассивФайлов = НайтиФайлы(ПутьКаталогаВыгрузкиДанных, "*.*");
	Проверить(МассивФайлов.Количество() = 0, "в каталоге <"+ПутьКаталогаВыгрузкиДанных+"> не должно быть файлов");
	
	строкаПутьКБазе = ПолучитьПодстрокуКомандыЗапуска1С_БазаДанных(ИмяКаталогаБазы);
	
	СтрокаЛогина = ПолучитьСтрокуЛогинаКомандыЗапуска1С(Пользователь, Пароль);
	
	АппЛог = ПолучитьВременноеИмяФайлаЛога();
	
	Команда = """"+мПараметры.ПутьКПлатформе83+"""" //ПутьК1С83
		+ " DESIGNER " + строкаПутьКБазе + " "
		+ СтрокаЛогина
		+ " /Visible"
		+ " /DumpConfigToFiles""" + ПутьКаталогаВыгрузкиДанных  + """"
		+ " /Lru"
		//для 1С 8.2 строка		+ " /DumpConfigFiles""" + ПутьКаталогаВыгрузкиДанных + """ -Module -Template -AllWritable -Right"
		+ " /Out"""+АппЛог+"""";
		
	СписокФайлов = НайтиФайлы(ПутьКаталогаВыгрузкиДанных, "*.*");
	ВывестиСообщение("ВыгрузитьМодули: команда "+ Команда);
	ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(Команда);
	
	резКаталогВыгрузкиВсехМодулей83 = ПутьКаталогаВыгрузкиДанных;
	
	МассивФайлов = НайтиФайлы(ПутьКаталогаВыгрузкиДанных,"*.*");
	Проверить(МассивФайлов.Количество() > 0, "в каталоге <"+ПутьКаталогаВыгрузкиДанных+"> должны быть файлы");
	
	БезопасноУдалитьВременныйФайл(АппЛог);
	
	Возврат Истина;
	
КонецФункции

Функция НовыйСписокПереименований()

	Возврат Новый Массив();
	
	// если использовать ТаблицуЗначений, то:
	// ТаблицаПереименований = Новый ТаблицаЗначений;
	// Переименования = Новый ТаблицаЗначений;
	// Переименования.Колонки.Добавить("Источник", Новый ОписаниеТипов("Строка", ,Новый КвалификаторыСтроки(500, ДопустимаяДлина.Переменная)));
	// Переименования.Колонки.Добавить("Приемник", Новый ОписаниеТипов("Строка", ,Новый КвалификаторыСтроки(500, ДопустимаяДлина.Переменная)));

КонецФункции

Функция ДобавитьПереименование(Знач Переименования, Знач Источник, Знач Приемник)

	СтрокаПереименования = Новый Структура;
	СтрокаПереименования.Вставить("Источник", Источник);
	СтрокаПереименования.Вставить("Приемник", Приемник);
	
	Переименования.Добавить(СтрокаПереименования);
	
	Возврат СтрокаПереименования;

КонецФункции

Функция РазложитьМодули1СПоПапкамСогласноИерархииМетаданных(КаталогВыгрузкиВсехМодулей83, КаталогВыгрузки) Экспорт
	Перем КаталогИерархическойСтруктурыМодулей;
	Перем КэшПереименований;
	Перем СоотвествиеИменФайловДляПропуска;
	
	ВывестиСообщение("Раскладываем модули по папкам согласно иерархии метаданных");
	
	КэшПереименований = Новый Соответствие;
	лПутьКаталогаВыгрузкиВсехМодулей83 = КаталогВыгрузкиВсехМодулей83; //ПутьКаталогаВыгрузки;
	Если Не ПроверитьСуществованиеФайлаКаталога(лПутьКаталогаВыгрузкиВсехМодулей83, "каталог выгрузки всех модулей 8.3 - РазложитьМодули1СПоПапкамСогласноИерархииМетаданных") Тогда
		Возврат Ложь;
	КонецЕсли;
		
	КаталогИерархическойСтруктурыМодулей = КаталогВыгрузки;
	Если ПустаяСтрока(КаталогИерархическойСтруктурыМодулей) Тогда
		ВывестиОшибку("не задан каталог выгрузки модулей по иерархии - РазложитьМодули1СПоПапкамСогласноИерархииМетаданных");
		Возврат Ложь;
	КонецЕсли;
		//ВызватьИсключение "КаталогИерархическойСтруктурыМодулей (разложенные модули) не должен равняться лПутьКаталогаВыгрузки (общий набор всех файлов выгруженных из 8.3)";
	
	лФайлВыгрузкиКаталог = Новый Файл(КаталогИерархическойСтруктурыМодулей);
	Если НЕ лФайлВыгрузкиКаталог.Существует() Тогда
		СоздатьКаталог(КаталогИерархическойСтруктурыМодулей);
		ЗарегистрироватьВременныйФайл(КаталогИерархическойСтруктурыМодулей);
		
		Проверить(лФайлВыгрузкиКаталог.Существует(), "Не существует каталог иерархии модулей <"+КаталогИерархическойСтруктурыМодулей+">. Выполнение остановлено!");
	КонецЕсли;
	
	ЗавершитьПроцесс_TGitCache_exe();
	
	ОчиститьКаталогРаспаковки(КаталогИерархическойСтруктурыМодулей);	
		
	Переименования = НовыйСписокПереименований();
	
	УдалитьИгнорируемыеТипыФайлов(лПутьКаталогаВыгрузкиВсехМодулей83);
	
	СписокФайлов = НайтиФайлы(лПутьКаталогаВыгрузкиВсехМодулей83, "*.*"); //СтруктураПараметров.КаталогВыгрузки
	Для каждого Файл Из СписокФайлов Цикл
		Если Файл.ЭтоКаталог() Тогда
			
			Если Прав(Файл.Имя, 5) = "files" Тогда // файлы справки. 
				МассивФайлов = НайтиФайлы(Файл.ПолноеИмя, "*.*");
				ИмяНовогоФайла = Лев(Файл.Имя, СтрДлина(Файл.Имя)-6);
				ИмяНовогоФайла = СтрЗаменить(ИмяНовогоФайла, ".", "\")+".del";
				НовыйФайл = Новый Файл(КаталогИерархическойСтруктурыМодулей+"\"+ИмяНовогоФайла);
				НовыйКаталог = Новый Файл(НовыйФайл.Путь);
				Если НЕ НовыйКаталог.Существует() Тогда
					СоздатьКаталог(НовыйКаталог.ПолноеИмя);
				КонецЕсли;
				НовыйФайл = Новый Файл(НовыйКаталог.ПолноеИмя+"\"+Файл.Имя);
				Если Не НовыйФайл.Существует() Тогда
					СоздатьКаталог(НовыйФайл.ПолноеИмя);
				КонецЕсли;
				Для каждого ЭлементЦикла Из МассивФайлов Цикл
					ДобавитьПереименование(Переименования, 
						Файл.Имя+"\"+ЭлементЦикла.Имя, 
						СтрЗаменить(НовыйФайл.ПолноеИмя+"\"+ЭлементЦикла.Имя, КаталогИерархическойСтруктурыМодулей+"\", ""));
				КонецЦикла;
			КонецЕсли;
			Продолжить;	
		КонецЕсли;
		ИмяФайла = Файл.ИмяБезРасширения;
		//Форма.Модуль --> МодульФормы
		Если Прав(ИмяФайла, 12) = "Форма.Модуль" Тогда
			ИмяФайла = Лев(ИмяФайла, СтрДлина(ИмяФайла)-12)+"МодульФормы";
		КонецЕсли;
		
		Если Прав(ИмяФайла, 6) = ".Макет" Тогда
			ИмяФайла = Лев(ИмяФайла, СтрДлина(ИмяФайла)-6);
		КонецЕсли;
		
		Если Прав(ИмяФайла, 17) = ".Картинка.Picture" Тогда
			ИмяФайла = Лев(ИмяФайла, СтрДлина(ИмяФайла)-17);
		КонецЕсли;
		
		Если Прав(ИмяФайла, 5) = ".Form" Тогда
			
		КонецЕсли;
		
		// Для 8.3 если файл содержит всего одну точку в имени, тогда создадим папки и туда его и кинем. 
		// 
		
		Если СтрЧислоВхождений(ИмяФайла, ".") = 1 Тогда
			//Увеличим наименование на Наименование объекта конфигурации описываемого. 
			//
			НаименованиеОбъектаМетаданных = Сред(ИмяФайла, Найти(ИмяФайла, "."));
			ИмяФайла = СтрЗаменить(ИмяФайла, НаименованиеОбъектаМетаданных,НаименованиеОбъектаМетаданных+НаименованиеОбъектаМетаданных);
		КонецЕсли;
		
		//{Определим длину Наименования папки, по умолчанию не больше 60 символов.  
		Если СтрДлина(ИмяФайла)>144 Тогда
		
			МассивИмен = РазложитьСтрокуВМассивПодстрок(ИмяФайла, ".");
			//Для каждого  Из  Цикл
			//КонецЦикла;
			//СтрокаПапки = Сред(ИмяФайла, Найти(ИмяФайла, "."));
			//СтрокаПапки = Сред(СтрокаПапки, 0, Найти(СтрокаПапки, "."));
			//Если СтрДлина(СтрокаПапки) > 59 Тогда
				
				ИмяФайла = "";
				Счетчик = 0;
				КоличествоВсего = МассивИмен.Количество();
				Для Счетчик = 0 По КоличествоВсего-1 Цикл
					ЭлементМассива = МассивИмен.Получить(Счетчик);
					НовоеИмя = ЭлементМассива;
					ДлинаИменни = СтрДлина(ЭлементМассива);
					//Если ДлинаИменни > 58 И (Счетчик <> (КоличествоВсего-1)) Тогда
					
					Если ДлинаИменни > 58 Тогда
						ВывестиОтладочноеСообщение("Слишком длинное имя:"+ЭлементМассива +" длина:"+ДлинаИменни);
						
						Если КэшПереименований.Получить(ЭлементМассива) <> Неопределено Тогда
							НовоеИмя = КэшПереименований.Получить(ЭлементМассива);
						Иначе
							Разрядность = СтрДлина(Строка(ДлинаИменни));
							НовоеИмя = Лев(ЭлементМассива, 58-Разрядность-1)+"~"+ДлинаИменни;
							НовыйПутьПроверки = Новый Файл(КаталогИерархическойСтруктурыМодулей+"\"+ИмяФайла+НовоеИмя);
							Если НовыйПутьПроверки.Существует() Тогда
								СчетчикНовогоИмени = 0;
								МассивФайловСущуствующих = НайтиФайлы(КаталогИерархическойСтруктурыМодулей+"\"+ИмяФайла, Лев(ЭлементМассива, 58-Разрядность-3)+"*");
								СчетчикНовогоИмени = МассивФайловСущуствующих.Количество()+1;
								НовоеИмя = Лев(ЭлементМассива, 58-Разрядность-3)+"~"+ДлинаИменни+ФорматДвузначноеЧисло(Строка(СчетчикНовогоИмени));
							КонецЕсли;
							
							КэшПереименований.Вставить(ЭлементМассива, НовоеИмя);
						КонецЕсли;
						
						ВывестиОтладочноеСообщение("Старое имя:"+ЭлементМассива +" новое имя:"+НовоеИмя);
					КонецЕсли;
					ИмяФайла=ИмяФайла+НовоеИмя+"\";
				КонецЦикла;
				ИмяФайла = ?(Прав(ИмяФайла,1)="\", Лев(ИмяФайла, СтрДлина(ИмяФайла)-1), ИмяФайла);
			//КонецЕсли;
		КонецЕсли;
		//}
		
		ИмяНовогоФайла = СтрЗаменить(ИмяФайла, ".", "\")+Файл.Расширение;
		Если Прав(ИмяНовогоФайла, 10) = "Module.txt" Тогда
			ИмяНовогоФайла = СтрЗаменить(ИмяНовогоФайла, "Module.txt", "Module.bsl"); //добавлена будущая поддержка 1S:DT
		КонецЕсли;
		
		НовыйФайл = Новый Файл(КаталогИерархическойСтруктурыМодулей+"\"+ИмяНовогоФайла);
		НовыйКаталог = Новый Файл(НовыйФайл.Путь);
		Если НЕ НовыйКаталог.Существует() Тогда
			СоздатьКаталог(НовыйКаталог.ПолноеИмя);
		КонецЕсли;
		
		ДобавитьПереименование(Переименования,Файл.Имя,ИмяНовогоФайла);
		
		КопироватьФайл(Файл.ПолноеИмя, НовыйФайл.ПолноеИмя);
		
		Если Прав(Файл.ПолноеИмя, 5) = ".Form" Тогда
			
			//Если ФайлПрограммыРаспаковки=Неопределено или НЕ ФайлПрограммыРаспаковки.Существует() тогда
			//	Инициализация();
			//КонецЕсли;
			
			КаталогФормы = НовыйКаталог.ПолноеИмя+"\"+НовыйФайл.ИмяБезРасширения;
			СоздатьКаталог(КаталогФормы);
			
			Если Не Распаковка(НовыйФайл.ПолноеИмя, КаталогФормы) Тогда
				Возврат Ложь;
			КонецЕсли; 
			
		КонецЕсли;
		//"000009d5 000009d5 7fffffff"
		
	КонецЦикла;
	
	ТекстовыйДокумент = Новый ЗаписьТекста(КаталогИерархическойСтруктурыМодулей+"\renames.txt");
	Для Каждого ЭлементСтроки Из Переименования Цикл
		ТекстовыйДокумент.ЗаписатьСтроку(ЭлементСтроки.Источник+"-->"+ЭлементСтроки.Приемник);
	КонецЦикла;
	ТекстовыйДокумент.Закрыть();
	//Переименования.Сортировать("Источник");
	// ТекстовыйДокумент = Новый ТекстовыйДокумент;
	// Для каждого ЭлементСтроки Из Переименования Цикл
		// ТекстовыйДокумент.ДобавитьСтроку(ЭлементСтроки.Источник+"-->"+ЭлементСтроки.Приемник);
	// КонецЦикла;
	// ТекстовыйДокумент.Записать(КаталогИерархическойСтруктурыМодулей+"\renames.txt");
	//----
	
	Возврат  Истина;
	
КонецФункции

Функция РазложитьКонфигурацию1СПоПапкамСогласноИерархииМетаданных(Пользователь, Пароль, ПутьКФайлуКонфигурации, КаталогВыгрузки, резИмяКаталогаБазы )
	
	Если НЕ СоздатьПустуюБазу(ПутьКФайлуКонфигурации, резИмяКаталогаБазы) Тогда
		ВывестиОшибку("Не удалось выполнить создание пустой базы по cf");
		Возврат Ложь;
	КонецЕсли; 
	
	КаталогВыгрузкиВсехМодулей83 = "";
	Если НЕ ВыгрузитьМодули(резИмяКаталогаБазы, Пользователь, Пароль, КаталогВыгрузкиВсехМодулей83) Тогда
		ВывестиОшибку("Не удалось выгрузить модули");
		Возврат Ложь;
	КонецЕсли; 
	
	Если НЕ РазложитьМодули1СПоПапкамСогласноИерархииМетаданных(КаталогВыгрузкиВсехМодулей83, КаталогВыгрузки) Тогда
		ВывестиОшибку("Не удалось выполнить копирование файлов");
		Возврат Ложь;
	КонецЕсли; 
	
	МассивФайлов = НайтиФайлы(резИмяКаталогаБазы, "*.*");
	БезопасноУдалитьВременныйФайл(резИмяКаталогаБазы);
	БезопасноУдалитьВременныйФайл(КаталогВыгрузкиВсехМодулей83);
		
	Возврат Истина;
КонецФункции

Функция СобратьМодули1СИзИерарархииМетаданныхВЛинейнуюСтруктуру(СтруктураПараметров) Экспорт
	Перем КаталогСтруктуры;
	

	ПутьКВременномуКаталогуПереименований = СоздатьВременныйКаталог();
		
	ИмяФайлаВыгрузкиКаталог = СтруктураПараметров.КаталогЗагрузки;
	файлВыгрузкиКаталог = Новый Файл(ИмяФайлаВыгрузкиКаталог);
	Проверить(файлВыгрузкиКаталог.Существует(), "файл с исходными данными не существует");
	Проверить(файлВыгрузкиКаталог.ЭтоКаталог(), "путь с исходными данными не каталог");
	
	файлПереименований = Новый Файл(файлВыгрузкиКаталог.ПолноеИмя + "\renames.txt");
	Проверить(файлПереименований.Существует(), "файл со списком переименований существует. ");

	ЗавершитьПроцесс_TGitCache_exe();
	
	ЕстьОшибка = Ложь;
	ЧтениеТекста = Новый ЧтениеТекста(файлПереименований.ПолноеИмя);
	
	Стр = ЧтениеТекста.ПрочитатьСтроку();
	Пока Стр <> Неопределено Цикл // строки читаются до символа перевода строки
		ИндексПоиска = Найти(Стр, "-->");
		Если СтрДлина(Стр)>0 И ИндексПоиска > 0 Тогда 
			
			ПутьФайлНовый = Сред(Стр, 0, ИндексПоиска-1);
			ПолныйПутьНовыйФайл = ПутьКВременномуКаталогуПереименований + "\"+ПутьФайлНовый;
			ПутьФайлСтарый = Сред(Стр, ИндексПоиска+3);
			ПолныйПутьСтарыйФайл = файлВыгрузкиКаталог.ПолноеИмя+"\"+ПутьФайлСтарый;
			Если Прав(ПолныйПутьНовыйФайл, 5) = ".Form" Тогда
				
				ФайлСтарый = Новый Файл(ПутьФайлСтарый);
				
				//Если ФайлПрограммыРаспаковки=Неопределено или НЕ ФайлПрограммыРаспаковки.Существует() тогда
				//	Инициализация();
				//КонецЕсли;
				
				КаталогФормы = ФайлСтарый.Путь+"\"+ФайлСтарый.ИмяБезРасширения;
				
				Если Не Упаковка(ФайлСтарый.ПолноеИмя, КаталогФормы) Тогда
					Возврат Ложь;
				КонецЕсли; 
			КонецЕсли;
			
			КопироватьФайл(ПолныйПутьСтарыйФайл, ПолныйПутьНовыйФайл);
			
		ИначеЕсли СтрДлина(Стр)>0 Тогда
			ЕстьОшибка = Истина;
			Прервать;
			
	    КонецЕсли;
		
		Стр = ЧтениеТекста.ПрочитатьСтроку();
	КонецЦикла;
	
	Если ЕстьОшибка Тогда
		Возврат Ложь;
	КонецЕсли;
	
	СтруктураПараметров.Вставить("ПутьКВременномуКаталогуПереименований", ПутьКВременномуКаталогуПереименований);

	Возврат  Истина;
	
КонецФункции


Функция ЗагрузитьМодули(СтруктураПараметров) Экспорт
	
	файлВыгрузкиКаталог = Новый Файл(СтруктураПараметров.ПутьКВременномуКаталогуПереименований);
	Проверить(файлВыгрузкиКаталог.Существует(), "Не существует каталог <"+СтруктураПараметров.ПутьКВременномуКаталогуПереименований+">. Выполнение остановлено!");
	
	МассивФайлов = НайтиФайлы(СтруктураПараметров.ПутьКВременномуКаталогуПереименований, "*.*");
	Проверить(МассивФайлов.Количество() > 0, "в каталоге <"+СтруктураПараметров.ПутьКВременномуКаталогуПереименований+"> не должно быть файлов");
			

	строкаПутьКБазе = ПолучитьПодстрокуКомандыЗапуска1С_БазаДанных(СтруктураПараметров.ИмяКаталогаБазы); //СтруктураПараметров.ПутьКБазе);
	
	строкаЛогина = ПолучитьПодстрокуКомандыЗапуска1С_ЛогинПароль(); //СтруктураПараметров.Пользователь, СтруктураПараметров.Пароль);
	
	АппЛог = ПолучитьВременноеИмяФайлаЛога();
	
	Команда = """"+мПараметры.ПутьКПлатформе83+""""
		+ " DESIGNER " + строкаПутьКБазе
		+ СтрокаЛогина
		+ " /Visible"
		+ " /LoadConfigFromFiles""" + СтруктураПараметров.ПутьКВременномуКаталогуПереименований + """"
		+ " /Lru"
		+ " /Out"""+АппЛог+"""";
		
		
	ВывестиОтладочноеСообщение("ЗагрузитьМодули: команда "+ Команда);
	ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(Команда);
	
	СписокСтрок = Новый Массив;
	//Пишет только при ошибке, поэтому считаем если нашли, то ошибка есть. 
	СписокСтрок.Добавить("Ошибка разбора");
	БылаОшибка = ПроверитьФайлНаОтсутствиеСтрок(АппЛог, СписокСтрок);
	
	Если БылаОшибка Тогда
		Возврат Ложь;
	Иначе
		БезопасноУдалитьВременныйФайл(АппЛог);

	КонецЕсли;
	
	Возврат Истина; //естьСтрокаВФайлеТрассировки;	
	
КонецФункции

Функция СобратьКонфигурацию1СПоПапкамСогласноИерархииМетаданных(СтруктураПараметров)
	
	Если НЕ СоздатьПустуюБазуБезШаблона(СтруктураПараметров) Тогда
		ВывестиОшибку("Не удалось выполнить создание пустой базы по cf");
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ СобратьМодули1СИзИерарархииМетаданныхВЛинейнуюСтруктуру(СтруктураПараметров) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ЗагрузитьМодули(СтруктураПараметров) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ СохранитьКонфигурациюИзБазы(СтруктураПараметров.ПутьКФайлуКонфигурации, СтруктураПараметров.ИмяКаталогаБазы) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	МассивФайлов = НайтиФайлы(СтруктураПараметров.ИмяКаталогаБазы, "*.*");
	Попытка
		УдалитьФайлы(СтруктураПараметров.ИмяКаталогаБазы);
	Исключение
		ВывестиОшибку(ОписаниеОшибки());
	КонецПопытки;
	
	МассивФайлов = НайтиФайлы(СтруктураПараметров.ПутьКВременномуКаталогуПереименований, "*.*");
	Попытка
		УдалитьФайлы(СтруктураПараметров.ПутьКВременномуКаталогуПереименований);
	Исключение
		ВывестиОшибку(ОписаниеОшибки());
	КонецПопытки;
	
	Возврат Истина;
КонецФункции

Функция КлонироватьРепозитарий(Знач КаталогЛокальнойКопии, Знач URLРепозитария) Экспорт
	
	Батник = СоздатьКомандныйФайл();
	
	ДобавитьВКомандныйФайл(Батник, ПодставитьПараметрыВСтроку("cd \d ""%1""", КаталогЛокальнойКопии));
	ФайлЛога = СоздатьВременныйФайл("log");
	ПараметрыКоманды = Новый Массив;
	ПараметрыКоманды.Добавить(ОбернутьВКавычки(мПараметры.ПутьGit));
	ПараметрыКоманды.Добавить("clone");
	ПараметрыКоманды.Добавить(URLРепозитария);
	ПараметрыКоманды.Добавить(ОбернутьВКавычки(КаталогЛокальнойКопии));
	ПараметрыКоманды.Добавить(СуффиксПеренаправленияВывода(ФайлЛога, Истина));
	
	КоманднаяСтрока = СобратьКоманднуюСтроку(ПараметрыКоманды);
	ВывестиОтладочноеСообщение(КоманднаяСтрока);
	ДобавитьВКомандныйФайл(Батник, КоманднаяСтрока);
	ДобавитьВКомандныйФайл(Батник, "exit /b %ERRORLEVEL%");
		
	РезультатКлонирования = ВыполнитьКомандныйФайл(Батник);
	
	ВывестиТекстФайла(ФайлЛога);
	
	Возврат РезультатКлонирования = 0;
	
КонецФункции

Процедура СформироватьПервичныйФайлПользователейДляGit(Знач ИмяФайлаХранилища, Знач ВыходнойФайл) Экспорт

	резПутьКХМЛФайлуВерсийХранилища1С = "";
	резПутьКХМЛФайлуПользователейХранилища1С = "";
	
	ВывестиОтладочноеСообщение("Формируем первичный файл авторов:
	| Файл хранилища: " + ИмяФайлаХранилища + "
	| Выходной файл: " + ВыходнойФайл);
	
	Если Не ВыгрузитьТаблицыВерсийИПользователейИзФайлаХранилища1С(ИмяФайлаХранилища, резПутьКХМЛФайлуВерсийХранилища1С, резПутьКХМЛФайлуПользователейХранилища1С) Тогда
		ВызватьИсключение "Не удалось выгрузить данные из файла хранилища 1С";
	КонецЕсли;
	
	ТаблицаПользователейХранилища = "";
	Если Не ПрочитатьФайлПользователей(резПутьКХМЛФайлуПользователейХранилища1С, ТаблицаПользователейХранилища) Тогда
		ВызватьИсключение "Ошибка чтения файла пользователей";
	КонецЕсли;
	
	ЗаписатьТаблицуПользователейВФайлАвторовGit(ТаблицаПользователейХранилища, ВыходнойФайл);
	
КонецПроцедуры

Процедура ЗаписатьТаблицуПользователейВФайлАвторовGit(Знач ТаблицаПользователейХранилища, Знач ВыходнойФайл)

	ЗаписьФайла = Новый ЗаписьТекста(ВыходнойФайл, "utf-8");
	Попытка
		ШаблонЗаписи = "%1=%1 <%1@%2>";
		Для Каждого Запись Из ТаблицаПользователейХранилища Цикл
			СтрокаДляЗаписи = ПодставитьПараметрыВСтроку(ШаблонЗаписи, Запись.Автор, мПараметры.ДоменПочтыДляGit);
			ЗаписьФайла.ЗаписатьСтроку(СтрокаДляЗаписи);
		КонецЦикла;
		
		ЗаписьФайла.Закрыть();
	Исключение
		ОсвободитьОбъект(ЗаписьФайла);
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

Функция ФорматДвузначноеЧисло(ЗначениеЧисло)
	С = Строка(ЗначениеЧисло);
	Если СтрДлина(С) < 2 Тогда
		С = "0" + С;
	КонецЕсли;
	
	Возврат С;
КонецФункции

Функция ДатаPOSIX(Знач Дата)
	
	Возврат "" + Год(Дата) + "-" + ФорматДвузначноеЧисло(Месяц(Дата)) + "-" + ФорматДвузначноеЧисло(День(Дата)) + " "
			+ ФорматДвузначноеЧисло(Час(Дата)) + ":" + ФорматДвузначноеЧисло(Минута(Дата)) + ":" + ФорматДвузначноеЧисло(Секунда(Дата));
	
	//Формат(Дата, "Л=en_US_POSIX; ДФ='yyyy-MM-dd hh:mm:ss'; ДЛФ=DDT")
	
КонецФункции

Функция ВыполнитьКоммитГит(КаталогРепозиторияГит, Комментарий, Автор, Дата=Неопределено) Экспорт 
 	
	Если Дата = Неопределено Тогда
		Дата = ТекущаяДата();
	КонецЕсли;

	ИмяФайлаКомментария = СоздатьВременныйФайл("txt");
	файлКомментария = Новый ЗаписьТекста(ИмяФайлаКомментария,"utf-8");
	файлКомментария.Записать("LOG: " + ?(ПустаяСтрока(Комментарий), ".", Комментарий));
	файлКомментария.Закрыть();
	ВывестиСообщение("Текст коммита: <"+Комментарий+">");
	
	КомандныйФайл = СоздатьКомандныйФайл();
	
	ПутьGit = ОбернутьВКавычки(мПараметры.ПутьGit);
	ДобавитьВКомандныйФайл(КомандныйФайл, "cd /d " + ОбернутьВКавычки(КаталогРепозиторияГит));
	ДобавитьВКомандныйФайл(КомандныйФайл, "set GIT_AUTHOR_DATE="+ОбернутьВКавычки(ДатаPOSIX(Дата)));
	ДобавитьВКомандныйФайл(КомандныйФайл, "set GIT_COMMITTER_DATE="+ОбернутьВКавычки(ДатаPOSIX(ТекущаяДата())));
	ДобавитьВКомандныйФайл(КомандныйФайл, ПутьGit + " add -A");
	
	ИмяФайлаЛогаКоммита = СоздатьВременныйФайл("log");
	
	авторДляГит = Автор;
	Если Найти(Автор, "<") <= Найти(Автор, ">") Тогда
		авторДляГит = Автор+" <"+Автор+"@localhost>"; // e-mail может быть удобен для поиска в связанных системах //авторДляГит = Автор+" <"+Автор+">";
	КонецЕсли; 
	
	КомандаКоммита = ПутьGit + " commit -a --file="""+ИмяФайлаКомментария+""" --author="""+Автор+""" >"+ИмяФайлаЛогаКоммита;
	ДобавитьВКомандныйФайл(КомандныйФайл, КомандаКоммита);
	ДобавитьВКомандныйФайл(КомандныйФайл, ПутьGit + " push");
	ДобавитьВКомандныйФайл(КомандныйФайл, "exit /b %ERRORLEVEL%");
	
	ИмяФайлаВыполнения = ЗакрытьКомандныйФайл(КомандныйФайл);
	
	текстФайла = "";
	Если ПолучитьТекстФайла(ИмяФайлаВыполнения, текстФайла) Тогда
		ВывестиСообщение("ВыполнитьКоммитГит: текст файла запуска "+Символы.ВК+текстФайла);
	Иначе
		ВывестиОшибку("ВыполнитьКоммитГит: не удалось вывести текст пакетного файла");
	КонецЕсли;
	
	рез = ВыполнитьКомандныйФайл(КомандныйФайл);
	
	ВывестиСообщение("ВыполнитьКоммитГит: Вызов git commit вернул код <" + рез + "> ");
	
	Если рез <> 0 Тогда
		текстФайла = "";
		успешно = ПолучитьТекстФайла(ИмяФайлаЛогаКоммита, текстФайла);
		Если успешно Тогда
			ВывестиОшибку("ВыполнитьКоммитГит: Лог команды git commit"+Символы.ПС+текстФайла);
		Иначе
			ВывестиОшибку("ВыполнитьКоммитГит: Не удалось получить лог команды git commit");
		КонецЕсли; 

	КонецЕсли;

	БезопасноУдалитьВременныйФайл(ИмяФайлаВыполнения);
	БезопасноУдалитьВременныйФайл(ИмяФайлаКомментария);
	
	Возврат рез = 0;
КонецФункции

Функция ПолучитьТекстФайла(ИмяФайла, резТекстФайла = "")
	
	// проверим есть ли файл
	Файл = Новый Файл(ИмяФайла);
	Если НЕ Файл.Существует() Тогда
		Возврат Ложь;
	КонецЕсли;

	ФайлОтчета = Новый ЧтениеТекста(ИмяФайла);
	МассивСтрок = Новый Массив;
	
	Попытка
		Стр = "";
		Пока Стр <> Неопределено Цикл
			Стр = ФайлОтчета.ПрочитатьСтроку();
			МассивСтрок.Добавить(Стр);
		КонецЦикла;
		ФайлОтчета.Закрыть();
	Исключение
		ВывестиОшибку("При выводе файла возникла ошибка: "+ОписаниеОшибки());
		Возврат Ложь;
	КонецПопытки;
	Если МассивСтрок.Количество() = 0 Тогда
		Возврат Ложь;
	КонецЕсли; 
	
	// вывести если строки не нашлись
	текстФайла = "+---/ "+ИмяФайла+" /-------------------------------";
	Для Инд = 0 По МассивСтрок.Количество()-1 Цикл
		текстФайла = текстФайла + Символы.ПС + "|"+МассивСтрок[Инд];
	КонецЦикла;
	текстФайла = текстФайла + Символы.ПС + "+-------------";
	резТекстФайла = текстФайла;

	Возврат Истина;
КонецФункции

Процедура ВывестиТекстФайла(Знач ИмяФайла, Знач Кодировка = Неопределено)

	Файл = Новый Файл(ИмяФайла);
	Если НЕ Файл.Существует() Тогда
		Возврат;
	КонецЕсли;
	
	Если Кодировка = Неопределено Тогда
		Кодировка = "utf-8";
	КонецЕсли;
	
	ЧТ = Новый ЧтениеТекста(ИмяФайла, Кодировка);
	СтрокаФайла = ЧТ.Прочитать();
	ЧТ.Закрыть();
	
	ВывестиСообщение(СтрокаФайла);

КонецПроцедуры

//Функция ПроверитьФайлНаОтсутствиеСтрок(ИмяФайла,СтрокаСравнение="",СтрокаПроверки=0) Экспорт
// возвращает истина если выведен_файл/не_найдена_фраза
Функция ПроверитьФайлНаОтсутствиеСтрок(ИмяФайла,СписокСтрокПоиска) //Экспорт
	
	// проверим есть ли файл
	Файл = Новый Файл(ИмяФайла);
	Если Файл.Существует() Тогда
		Попытка
			ФайлОтчета = Новый ЧтениеТекста(ИмяФайла);
		Исключение
			ФайлОтчета.Закрыть();
			ВывестиОшибку("При выводе файла возникла ошибка: "+ОписаниеОшибки());
			Возврат Ложь;
		КонецПопытки;
		
		Попытка
			Стр = ФайлОтчета.ПрочитатьСтроку();
			Если Стр = Неопределено Тогда
				ФайлОтчета.Закрыть();
				Возврат Ложь;
			КонецЕсли;
			
			СтрокиФайла = Новый Массив;
			СтрокиФайла.Добавить(Стр);
			Пока Стр <> Неопределено Цикл
				Стр = ФайлОтчета.ПрочитатьСтроку();
				СтрокиФайла.Добавить(Стр);
			КонецЦикла;
			ФайлОтчета.Закрыть();
		Исключение
			ФайлОтчета.Закрыть();
			ВызватьИсключение;
		КонецПопытки;
		
		// надо ли выводить при ошибке
		Если СписокСтрокПоиска <> Неопределено Тогда
			Для Инд = 0 По СтрокиФайла.Количество()-1 Цикл
				СтрокаПроверки = ВРег(СтрокиФайла[Инд]);
				Для Каждого СтрПоиска Из СписокСтрокПоиска Цикл
					ВФразаПоиска = ВРег(СтрПоиска);
					Если СтрЧислоВхождений(СтрокаПроверки, ВФразаПоиска) <> 0 Тогда
						// не будем выводить
						Возврат Ложь;
					КонецЕсли;
				КонецЦикла;
			КонецЦикла;
		КонецЕсли;
		
		// вывести если строки не нашлись
		текстФайла = "+---/ "+ИмяФайла+" /-------------------------------";
		Для Инд = 0 По СтрокиФайла.Количество()-1 Цикл
			текстФайла = текстФайла + "|"+СтрокиФайла[Инд];
		КонецЦикла;
		текстФайла = текстФайла + "+-------------";
		ВывестиСообщение(текстФайла);
	КонецЕсли;
	
	Возврат Истина;
КонецФункции

Функция ЗапуститьПакетныйФайл(Знач ПутьПакетногоФайла)

	СтрокаЗапуска = "cmd.exe /C """ + ПутьПакетногоФайла + """";
	
	Возврат ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(СтрокаЗапуска);
	
КонецФункции

Функция ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(Знач СтрокаЗапуска, Знач ТекущийКаталог = "\.") Экспорт 
	
	рез = -1;

	Попытка
		
		КодВозврата = "";
		ЗапуститьПриложение(СтрокаЗапуска, ТекущийКаталог, Истина, КодВозврата);
		рез = КодВозврата;
		
		// имяФайлаЗапуска = СоздатьВременныйФайл("cmd"); 
		
		// Сообщить(СтрокаЗапуска);
		// дескрипторФайлаЗапуска = Новый ЗаписьТекста(имяФайлаЗапуска, "utf-8");
		// дескрипторФайлаЗапуска.ЗаписатьСтроку("%windir%\Sysnative\" + СтрокаЗапуска);
		// дескрипторФайлаЗапуска.Закрыть();
				
		// _процесс = СоздатьПроцесс(имяФайлаЗапуска, ТекущийКаталог, Истина, Истина);
		//_процесс.ОжидатьЗавершения();
		
		// _процесс.Запустить();
		
		// Сообщить(_процесс.ПотокВывода.Прочитать());
		
		// рез = _процесс.КодВозврата;
	
		// БезопасноУдалитьВременныйФайл(имяФайлаЗапуска);
		
	Исключение
		// Для x64 ОС
		Сообщить(ОписаниеОшибки());
		СтрокаЗапуска = "%windir%\Sysnative\" + СтрокаЗапуска;
		КодВозврата = "";
		ЗапуститьПриложение(СтрокаЗапуска, ТекущийКаталог, Истина, КодВозврата);
		рез = КодВозврата;
	КонецПопытки;
		
	Возврат рез;
	
КонецФункции // ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения()

Процедура Sleep(чСекунд) Экспорт
	
	Приостановить(чСекунд * 1000);
	
КонецПроцедуры

// Код решает проблему с багом:
// TODO иногда бывает баг параллельной работы: при одновременном запуске (с точностью до секунды) двух пакетных выгрузок один из запущенных процессов 1С зависает.
// а в итоге висит и обработчик 1C2Git. Для продолжения работы нужно удалить запущенный процесс.
// баг найден на 8.3.3.721
//
//	Для работы метода нужно наличие в конфигурации следующей константы:
// 		ВремяПоследнегоЗапускаКонфигуратора1СФоновымЗаданием, тип Дата (дата и время)
Функция МожноЗапускатьКонфигураторВПакетномРежиме(ЗадержкаСПоследнегоЗапуска = 5, КоличествоПопыток = 3) Экспорт
	// НачатьТранзакцию(РежимУправленияБлокировкойДанных.Управляемый);
	
	// Блокировка = Новый БлокировкаДанных();
	// ЭлементБлокировки = Блокировка.Добавить("Константа.ВремяПоследнегоЗапускаКонфигуратора1СФоновымЗаданием");
	// ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
			
	// КонстантаУспешноОбновлена = Ложь;
	// СчИтераций = 1;
	// Пока Не КонстантаУспешноОбновлена И (КоличествоПопыток = 0 Или СчИтераций <= КоличествоПопыток) Цикл
		// Попытка
			// Блокировка.Заблокировать();
			
			// ВремяПоследнегоЗапускаКонфигуратора = Константы.ВремяПоследнегоЗапускаКонфигуратора1СФоновымЗаданием.Получить();
			// ПрошлоВремени = ТекущаяДата() - ВремяПоследнегоЗапускаКонфигуратора;
			// Если ЗадержкаСПоследнегоЗапуска > ПрошлоВремени Тогда
				// ВремяОжидания = ЗадержкаСПоследнегоЗапуска - ПрошлоВремени;
				// Sleep(ВремяОжидания);
			// КонецЕсли;
			
			// Константы.ВремяПоследнегоЗапускаКонфигуратора1СФоновымЗаданием.Установить(ТекущаяДата());
			
			// КонстантаУспешноОбновлена = Истина;
		// Исключение
			// Ошибка = ОписаниеОшибки();
			// ЗаписьЖурналаРегистрации("ПакетныйРежим", УровеньЖурналаРегистрации.Ошибка, , , Ошибка);
		// КонецПопытки;
		
		// СчИтераций = СчИтераций + 1;
	// КонецЦикла;
	
	// Если ТранзакцияАктивна() Тогда
		// Если КонстантаУспешноОбновлена Тогда
			// ЗафиксироватьТранзакцию();
		// Иначе
			// ОтменитьТранзакцию();
		// КонецЕсли;
	// КонецЕсли; 
	
	// Возврат КонстантаУспешноОбновлена;
	Возврат Истина;
КонецФункции

Функция ПолучитьПодстрокуКомандыЗапуска1С_БазаДанных(парамПутьКБазе)
	
	КлючПутьКБазе = " /F """ + парамПутьКБазе + """";
	Возврат КлючПутьКБазе;
	
	// Если 0 = Найти(НРег(парамПутьКБазе),"srvr") Тогда
		// лПутьКБазе = " /F """ + парамПутьКБазе + """";
	// Иначе
		// лИмяКластераСерверов = НСтр(парамПутьКБазе, "Srvr");
		// лИмяБазы = НСтр(парамПутьКБазе, "Ref");
		
		// лПутьКБазе = " /S """ + лИмяКластераСерверов + "\" + лИмяБазы + """";
	// КонецЕсли;
	// Возврат лПутьКБазе;
КонецФункции

Функция ПолучитьСтрокуЛогинаКомандыЗапуска1С(Пользователь, Пароль)
	СтрокаЛогина = "";
	Если ЗначениеЗаполнено(Пользователь) Тогда
		СтрокаЛогина = ПолучитьПодстрокуКомандыЗапуска1С_ЛогинПароль(Пользователь, Пароль); 
			//СтрокаЛогина = " /N " + СтруктураПараметров.Пользователь
			//	+ " /P """ + СтруктураПараметров.Пароль + """";
	КонецЕсли;
	Возврат СтрокаЛогина;
КонецФункции

Функция ПолучитьПодстрокуКомандыЗапуска1С_ЛогинПароль(парамЛогин = "", парамПароль = "")
	СтрокаЛогина = "";
	Если ЗначениеЗаполнено(парамЛогин) Тогда
		СтрокаЛогина = " /N """ + парамЛогин
			+ """ /P """ + парамПароль + """";
	КонецЕсли;
	Возврат СтрокаЛогина;
КонецФункции

Процедура СохранитьРеквизитыИТабличныеЧасти (Объект, ИмяФайлаXML=Неопределено) //Экспорт
    // ОВСЯНКИН - код не используется
	// ФайлXML = Новый ЗаписьXML;
    // ФайлXML.ОткрытьФайл(ИмяФайлаXML);
    // ФайлXML.ЗаписатьОбъявлениеXML();
    // ФайлXML.ЗаписатьНачалоЭлемента("Root");
    // ФайлXML.ЗаписатьАтрибут("Объект",Объект.Метаданные().Имя);
// //Сохраняем реквизиты
    // Для Каждого Реквизит Из Объект.Метаданные().Реквизиты Цикл
        // ФайлXML.ЗаписатьНачалоЭлемента("Реквизит");
        // ФайлXML.ЗаписатьАтрибут("Имя", Реквизит.Имя);
        // ТипЗначения = ТипЗнч(Объект[Реквизит.Имя]);
        // Если Не ТипЗначения = Тип("Неопределено") Тогда
            // ФайлXML.ЗаписатьАтрибут("ИмяТипа", XMLТип(ТипЗначения).ИмяТипа);
            // ФайлXML.ЗаписатьАтрибут("URI", XMLТип(ТипЗначения).URIПространстваИмен);
        // КонецЕсли;
        // ФайлXML.ЗаписатьТекст(XMLСтрока(Объект[Реквизит.Имя]));
        // ФайлXML.ЗаписатьКонецЭлемента();
    // КонецЦикла;
// //Сохраняем табличные части
    // Для Каждого ТЧ из Объект.Метаданные().ТабличныеЧасти Цикл
        // ФайлXML.ЗаписатьНачалоЭлемента("ТабличнаяЧасть");
        // ФайлXML.ЗаписатьАтрибут("Имя", ТЧ.Имя);
        // Для Каждого СтрокаТЧ из Объект[ТЧ.Имя] Цикл
            // ФайлXML.ЗаписатьНачалоЭлемента("ЭлементКоллекции");
            // Для Каждого РеквизитТЧ Из ТЧ.Реквизиты Цикл
                // ФайлXML.ЗаписатьНачалоЭлемента("Реквизит");
                // ФайлXML.ЗаписатьАтрибут("Имя", РеквизитТЧ.Имя);
                // ТипЗначения = ТипЗнч(СтрокаТЧ[РеквизитТЧ.Имя]);
                // Если Не ТипЗначения = Тип("Неопределено") Тогда
                    // ФайлXML.ЗаписатьАтрибут("ИмяТипа", XMLТип(ТипЗначения).ИмяТипа);
                    // ФайлXML.ЗаписатьАтрибут("URI", XMLТип(ТипЗначения).URIПространстваИмен);
                // КонецЕсли;
                // ФайлXML.ЗаписатьТекст(XMLСтрока(СтрокаТЧ[РеквизитТЧ.Имя]));
                // ФайлXML.ЗаписатьКонецЭлемента();
            // КонецЦикла;
            // ФайлXML.ЗаписатьКонецЭлемента();
        // КонецЦикла;
        // ФайлXML.ЗаписатьКонецЭлемента();
    // КонецЦикла;
	// // ОВСЯНКИН - всегда Истинное условие, но литерал Null не поддерживается oscript
    // //Если Не ФайлXML=Null Тогда
        // ФайлXML.ЗаписатьКонецЭлемента();
        // ФайлXML.Закрыть();
    // //КонецЕсли;
КонецПроцедуры

Процедура ЗагрузитьРеквизитыИТабличныеЧасти(Объект, ИмяФайлаXML=Неопределено) //Экспорт
    // Если Не ИмяФайлаXML = Неопределено Тогда
        // ФайлXML = Новый ЧтениеXML;
        // ФайлXML.ОткрытьФайл(ИмяФайлаXML);
        // Пока ФайлXML.Прочитать() Цикл
            // Если ФайлXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
                // ЗагрузитьОбъектРекурсивно(ФайлXML, Объект, ФайлXML.Имя);
            // КонецЕсли
        // КонецЦикла;
    // КонецЕсли;
КонецПроцедуры

Процедура ЗагрузитьОбъектРекурсивно(ФайлXML, Объект, знач ИмяУзла)
    // ИмяТипа = "";
    // ПространствоИмен = "";
    // Пока ФайлXML.ПрочитатьАтрибут() Цикл
        // Если ФайлXML.Имя = "ИмяТипа" Тогда
            // ИмяТипа = ФайлXML.Значение;
        // ИначеЕсли ФайлXML.Имя = "URI" Тогда
            // ПространствоИмен = ФайлXML.Значение;
        // КонецЕсли;
    // КонецЦикла;
    // Пока ФайлXML.Прочитать() Цикл
        // Если ФайлXML.ТипУзла = ТипУзлаXML.КонецЭлемента И ФайлXML.Имя = ИмяУзла Тогда
            // Возврат;
        // ИначеЕсли ФайлXML.ТипУзла = ТипУзлаXML.Текст Тогда
            // ТипОбъекта = ИзXMLТипа(ИмяТипа, ПространствоИмен);
            // Если НЕ ТипОбъекта = Неопределено тогда
                // Объект = XMLЗначение(ТипОбъекта, ФайлXML.Значение);
            // КонецЕсли;
        // ИначеЕсли ФайлXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
            // ИмяТекУзла = ФайлXML.Имя;
            // Если ФайлXML.Имя = "ЭлементКоллекции" Тогда
                // ЗагрузитьОбъектРекурсивно(ФайлXML, Объект.Добавить(), ИмяТекУзла);
            // Иначе
                // Если ФайлXML.ПрочитатьАтрибут() Тогда
                    // ЗагрузитьОбъектРекурсивно(ФайлXML, Объект[ФайлXML.Значение], ИмяТекУзла);
                // КонецЕсли;
            // КонецЕсли;
        // КонецЕсли;
    // КонецЦикла;
КонецПроцедуры

Процедура ОбработатьПараметрыЗапуска(ПараметрЗапуска, СтруктураПараметров = Неопределено) Экспорт
	Перем Путь;
	Перем ВыгрузитьДанные, ЗагрузитьДанные, мАвтозапуск, ПутьКФайлуЛогов, ПутьКХранилищу1C;
	Перем МаксимальнаяВерсияРазбора;
	
	Если ПустаяСтрока(ПараметрЗапуска) Тогда
		Возврат ;
	КонецЕсли;
	
	ВыгрузитьДанные					= Ложь;
	ЗагрузитьДанные					= Ложь;
	СинхронизироватьХранилищеВГит	= Ложь;
	мАвтозапуск						= Ложь;
	ПутьКФайлуЛогов					= "";
	РабочийКаталог					= "";

	
	Если Не ЗначениеЗаполнено(СтруктураПараметров) Тогда
		СтруктураПараметров = Новый Структура;//("КаталогВыгрузки", КаталогВыгрузки);
	КонецЕсли; 
	
	// Параметр может состоять из частей, разделенных символом ";".
	// Первая часть - главное значение параметра запуска. 
	// Наличие дополнительных частей определяется логикой обработки главного параметра.
	МассивПараметрыЗапуска = РазложитьСтрокуВМассивПодстрок(ПараметрЗапуска,";");
	Для Номер = 0 По МассивПараметрыЗапуска.Количество()-1 Цикл
		ЭлементМассива = МассивПараметрыЗапуска.Получить(Номер);
		Если ВРег(ЭлементМассива) = ВРег("path83") И Номер+1<=МассивПараметрыЗапуска.Количество()-1 Тогда
			Путь = МассивПараметрыЗапуска.Получить(Номер+1);
			Файл = Новый Файл(Путь);
			Если НЕ Файл.Существует() ИЛИ НЕ Файл.ЭтоФайл() Тогда
				мПараметры.ПутьКПлатформе83 = ПолучитьПутьПлатформы83();
			Иначе
				мПараметры.ПутьКПлатформе83 = Путь;
			КонецЕсли;
		ИначеЕсли ВРег(ЭлементМассива) = ВРег("pathToCF") И Номер+1<=МассивПараметрыЗапуска.Количество()-1 Тогда
			Путь = МассивПараметрыЗапуска.Получить(Номер+1);
			ПутьКФайлуКонфигурации = Путь;
			СтруктураПараметров.Вставить("ПутьКФайлуКонфигурации", ПутьКФайлуКонфигурации);
				//Файл = Новый Файл(Путь);
				//Если НЕ Файл.Существует() ИЛИ НЕ Файл.ЭтоФайл() Тогда
				//	ПутьКФайлуКонфигурации = "";
				//Иначе
				//	ПутьКФайлуКонфигурации = Путь;
				//КонецЕсли;
				//СтруктураПараметров.Вставить("ПутьКФайлуКонфигурации", ПутьКФайлуКонфигурации);
			
		ИначеЕсли ВРег(ЭлементМассива) = ВРег("pathOut") И Номер+1<=МассивПараметрыЗапуска.Количество()-1 Тогда
			
			Путь = МассивПараметрыЗапуска.Получить(Номер+1);
			КаталогВыгрузки = Путь; //ПутьККаталогуДляВыгрузки
			Файл = Новый Файл(Путь);
			Если НЕ Файл.Существует() ИЛИ НЕ Файл.ЭтоКаталог() Тогда
				Попытка
					СоздатьКаталог(Путь); // TODO нужно ли удалять каталог ??
					//КаталогВыгрузки = Путь; //ПутьККаталогуДляВыгрузки
				Исключение
					//КаталогВыгрузки = ""; //ПутьККаталогуДляВыгрузки
				КонецПопытки;
			//Иначе
			//	КаталогВыгрузки = Путь; //ПутьККаталогуДляВыгрузки
			КонецЕсли;
			СтруктураПараметров.Вставить("КаталогВыгрузки", ДополнитьСлешВПуть(КаталогВыгрузки));
			
		ИначеЕсли ВРег(ЭлементМассива) = ВРег("pathRepo") И Номер+1<=МассивПараметрыЗапуска.Количество()-1 Тогда
			
			Путь = МассивПараметрыЗапуска.Получить(Номер+1);
			ПутьКХранилищу1C = Путь; //ПутьККаталогуДляВыгрузки
				//Файл = Новый Файл(Путь);
				//Если НЕ Файл.Существует() Тогда
				//	ПутьКХранилищу1C = ""; //ПутьККаталогуДляВыгрузки
				//Иначе
				//	ПутьКХранилищу1C = Файл.ПолноеИмя; //ПутьККаталогуДляВыгрузки
				//КонецЕсли;
			СтруктураПараметров.Вставить("ПутьКХранилищу1C", ПутьКХранилищу1C); // TODO это разные объекты - здесь каталог
			СтруктураПараметров.Вставить("ПутьКФайлуХранилища1С", ПутьКХранилищу1C); // TODO это разные объекты - а вот здесь файл
		ИначеЕсли ВРег(ЭлементМассива) = ВРег("maxVersions") И Номер+1<=МассивПараметрыЗапуска.Количество()-1 Тогда
			МаксимальнаяВерсияРазбора = МассивПараметрыЗапуска.Получить(Номер+1);
		ИначеЕсли ВРег(ЭлементМассива) = ВРег("pathTemp") И Номер+1<=МассивПараметрыЗапуска.Количество()-1 Тогда
			
			РабочийКаталог = МассивПараметрыЗапуска.Получить(Номер+1);
			
		КонецЕсли;
		
		Если ВРег(ЭлементМассива) = ВРег("auto") Тогда
			мАвтозапуск = Истина;
		КонецЕсли;
		
		Если ВРег(ЭлементМассива) = ВРег("decompile") Тогда
			ВыгрузитьДанные = Истина;
		КонецЕсли;
		
		Если ВРег(ЭлементМассива) = ВРег("compile") Тогда
			ЗагрузитьДанные = Истина;
		КонецЕсли;
		
		Если ВРег(ЭлементМассива) = ВРег("sync1ctogit") Тогда
			СинхронизироватьХранилищеВГит = Истина;
		КонецЕсли;
		
		Если ВРег(ЭлементМассива) = ВРег("out") Тогда
			
			Путь = УбратьОбрамляющиеКавычкиЕслиЕсть(МассивПараметрыЗапуска.Получить(Номер+1));
			ПутьКФайлуЛогов = Путь;
			
		КонецЕсли;
		
		
	КонецЦикла;
	
	Инициализация(ПолучитьПараметрыИнициализации());
	
	// #Если ТолстыйКлиентОбычноеПриложение Тогда
		// ЗаписатьОшибкуВЛог(ПутьКФайлуЛогов, 1);
	// #КонецЕсли
	
	Если ВыгрузитьДанные Тогда
		
		//лКаталогВыгрузки = "";
		лИмяКаталогаБазы = "";
		успешно = РазложитьКонфигурацию1СПоПапкамСогласноИерархииМетаданных("", "", ПутьКФайлуКонфигурации, КаталогВыгрузки, лИмяКаталогаБазы);
		СтруктураПараметров.Вставить("ПутьКGit", КаталогВыгрузки); //СтруктураПараметров.КаталогВыгрузки);
		
		Проверить(успешно, "РазложитьКонфигурацию1СПоПапкамСогласноИерархииМетаданных");
		//Проверить(РазложитьКонфигурацию1СПоПапкамСогласноИерархииМетаданных(СтруктураПараметров), "РазложитьКонфигурацию1СПоПапкамСогласноИерархииМетаданных");
	
	ИначеЕсли ЗагрузитьДанные = Истина Тогда
		
		Если СтруктураПараметров.Свойство("КаталогВыгрузки") Тогда
			СтруктураПараметров.Вставить("КаталогЗагрузки", СтруктураПараметров.КаталогВыгрузки);
		КонецЕсли;

		Проверить(СобратьКонфигурацию1СПоПапкамСогласноИерархииМетаданных(СтруктураПараметров), "СобратьКонфигурацию1СПоПапкамСогласноИерархииМетаданных");	
		
	ИначеЕсли СинхронизироватьХранилищеВГит = Истина Тогда
		
		СтруктураПараметров.Вставить("МаксимальнаяВерсия", МаксимальнаяВерсияРазбора);
		Проверить(СинхронизироватьХранилищеКонфигурацийСГит(СтруктураПараметров), "СинхронизироватьХранилищеКонфигурацийСГит");
		
	КонецЕсли;
	
		
КонецПроцедуры
 
Функция ПолучитьПутьКНовойБазе1С(папкаДляСозданияБазыПоУмолчанию = "")
	Если НЕ ЗначениеЗаполнено(папкаДляСозданияБазыПоУмолчанию) Тогда
		лИмяКаталога = СоздатьВременныйКаталог();
	Иначе
		лИмяКаталога = папкаДляСозданияБазыПоУмолчанию;
	КонецЕсли;
	
	лКаталог = Новый Файл(лИмяКаталога);
	Если лКаталог.Существует() Тогда
		Попытка
			УдалитьФайлы(лИмяКаталога);
		Исключение
		    ошибка = ОписаниеОшибки();
			ВызватьИсключение "Не удалось удалить папку для новой тестовой базы"; 
		КонецПопытки; 
	КонецЕсли; 
	
	СоздатьКаталог(лИмяКаталога); // TODO нужно ли удалять каталог?? изучить вызовы метода
	Проверить(лКаталог.Существует(), "Не удалось создать папку для новой тестовой базы");
	
	Возврат лИмяКаталога;
КонецФункции

////////////////////////////////////////////
// Работа с временными файлами
 
Процедура ЗарегистрироватьВременныйФайл(Знач ПутьФайла)
	
	Если мКонтекстВыполнения.ВременныеФайлы.Найти(ПутьФайла) = Неопределено Тогда
		мКонтекстВыполнения.ВременныеФайлы.Добавить(ПутьФайла);	
	КонецЕсли;
	
КонецПроцедуры

Процедура УдалитьЗарегистрированныеВременныеФайлы() Экспорт
	Если мКонтекстВыполнения = Неопределено или мКонтекстВыполнения.ВременныеФайлы = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	
	КрайнийИндекс = мКонтекстВыполнения.ВременныеФайлы.Количество()-1;
	Для Сч = 0 По КрайнийИндекс Цикл
		
		Индекс = КрайнийИндекс-Сч;
		ИмяВременногоФайла = мКонтекстВыполнения.ВременныеФайлы[Индекс];
		Если БезопасноУдалитьВременныйФайл(ИмяВременногоФайла) Тогда
			ВывестиОтладочноеСообщение("Удален файл/папка " + ИмяВременногоФайла);
			мКонтекстВыполнения.ВременныеФайлы.Удалить(Индекс);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры
 
Функция БезопасноУдалитьВременныйФайл(Путь)
	
	Попытка
		УдалитьФайлы(Путь);
		Возврат Истина;
	Исключение
		Ошибка = "Попытка удаления "+Путь+" закончилась неудачей, по причине "+ОписаниеОшибки();
		УдаляемыйФайл = Новый Файл(Путь);
		Если УдаляемыйФайл.ЭтоФайл() и УдаляемыйФайл.ПолучитьТолькоЧтение() Тогда
			УдаляемыйФайл.УстановитьТолькоЧтение(ложь);
			Попытка
				УдалитьФайлы(Путь);
				Возврат Истина;
			Исключение
				ВывестиСообщение(ошибка);
			 КонецПопытки;
		Иначе
			ВывестиСообщение(ошибка);
		КонецЕсли; 
	КонецПопытки;

	Возврат Ложь;
КонецФункции

Функция ОчиститьКаталогРаспаковки(Знач КаталогИерархическойСтруктурыМодулей)
	СоответствиеИменФайловДляПропуска = Новый Соответствие;
	СоответствиеИменФайловДляПропуска.Вставить(".git", Истина);
	СоответствиеИменФайловДляПропуска.Вставить("AUTHORS", Истина); //Соответствие авторов и транслитерации. 
	СоответствиеИменФайловДляПропуска.Вставить("VERSION", Истина); //Номер версии, может использоватся для синхронизации с хранилищем. 
	
	
	//Удалим все каталоги с файлами в папке для разбора, кроме папки, начинающейся с с точки.
	ЕстьОшибкаУдаления = Ложь;
	МассивФайлов = НайтиФайлы(КаталогИерархическойСтруктурыМодулей, "*.*");
	Если МассивФайлов.Количество()>0 Тогда
		Для каждого ЭлементМассива Из МассивФайлов Цикл
			Если СоответствиеИменФайловДляПропуска.Получить(ЭлементМассива.Имя) = Истина Тогда
				Продолжить;
			КонецЕсли;
			Попытка
				УдалитьФайлы(ЭлементМассива.ПолноеИмя);
			Исключение
				ЕстьОшибкаУдаления = Истина;
			КонецПопытки;
		КонецЦикла;
	КонецЕсли;
	
	Если ЕстьОшибкаУдаления Тогда
		
		ЕстьОшибкаУдаления = Ложь;
		МассивФайлов = НайтиФайлы(КаталогИерархическойСтруктурыМодулей, "*.*");
		Если МассивФайлов.Количество()>0 Тогда
			Для каждого ЭлементМассива Из МассивФайлов Цикл
				Если СоответствиеИменФайловДляПропуска.Получить(ЭлементМассива.Имя) = Истина Тогда
					Продолжить;
				КонецЕсли;
				//Попытка
					УдалитьФайлы(ЭлементМассива.ПолноеИмя);
				//Исключение
				//	ЕстьОшибкаУдаления = Истина;
				//КонецПопытки;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
КонецФункции

Функция ЗавершитьПроцесс_TGitCache_exe()
	СтрокаКомманды = "taskkill /im TGitCache.exe  /T /F";
	ВывестиОтладочноеСообщение("ЗавершитьПроцесс_TGitCache_exe: команда "+ СтрокаКомманды);

	ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(СтрокаКомманды);
КонецФункции



Функция РазложитьСтрокуВМассивПодстрок(Знач Строка, Знач Разделитель = ",", Знач ПропускатьПустыеСтроки = Неопределено)
	
	Результат = Новый Массив;
	
	// для обеспечения обратной совместимости
	Если ПропускатьПустыеСтроки = Неопределено Тогда
		ПропускатьПустыеСтроки = ?(Разделитель = " ", Истина, Ложь);
		Если ПустаяСтрока(Строка) Тогда 
			Если Разделитель = " " Тогда
				Результат.Добавить("");
			КонецЕсли;
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;
	//
	
	Позиция = Найти(Строка, Разделитель);
	Пока Позиция > 0 Цикл
		Подстрока = Лев(Строка, Позиция - 1);
		Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Подстрока) Тогда
			Результат.Добавить(Подстрока);
		КонецЕсли;
		Строка = Сред(Строка, Позиция + СтрДлина(Разделитель));
		Позиция = Найти(Строка, Разделитель);
	КонецЦикла;
	
	Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Строка) Тогда
		Результат.Добавить(Строка);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции 

Процедура ВывестиСообщение(сообщение) Экспорт
	ВывестиСообщениеИлиОшибку(сообщение, Ложь);
КонецПроцедуры

Процедура ВывестиОшибку(сообщение) Экспорт
	ВывестиСообщениеИлиОшибку(сообщение, Истина);
КонецПроцедуры

Процедура ВывестиСообщениеИлиОшибку(Знач Сообщение, Знач ЭтоОшибка) Экспорт
	Сообщить(Сообщение);
	
	// Если ВыводитьСообщенияВЖурналРегистрации Тогда
		// ЗаписьЖурналаРегистрации("1C2Git", ?(ошибка, УровеньЖурналаРегистрации.Ошибка, УровеньЖурналаРегистрации.Информация), , , сообщение);
	// КонецЕсли; 

КонецПроцедуры

Процедура ВывестиОтладочноеСообщение(Знач Сообщение) Экспорт
	Если РежимОтладки() Тогда
		ВывестиСообщение(Сообщение);
	КонецЕсли;	
КонецПроцедуры

Функция УбратьОбрамляющиеКавычкиЕслиЕсть(текст) Экспорт
	лЗначение = текст;
	Если Лев(лЗначение, 1) = """" Тогда
		лЗначение = Сред(лЗначение, 2);
	КонецЕсли;
	Если Прав(лЗначение, 1) = """" Тогда
		лЗначение = Сред(лЗначение, 1, СтрДлина(лЗначение)-1);
	КонецЕсли;
	Возврат лЗначение;
КонецФункции

Функция ФорматДСО(ДопСообщениеОшибки)
	Если ДопСообщениеОшибки = "" Тогда
		Возврат "";
	КонецЕсли;
	
	Возврат Символы.ПС + ДопСообщениеОшибки;
КонецФункции

Процедура Проверить(Знач УсловиеВерно, ДопСообщениеОшибки = "") //Экспорт
	СообщениеОшибки = "Переданный параметр ("+УсловиеВерно+") не является Истиной, а хотели, чтобы являлся." + ФорматДСО(ДопСообщениеОшибки);
	
	Если Не УсловиеВерно Тогда
		ВызватьИсключение(СообщениеОшибки);
	КонецЕсли;
КонецПроцедуры

Процедура ИниФайлСтруктура_Добавить(ИниФайлСтруктура, Группа, Ключ, Значение);
	Отбор = Новый Структура;
	Отбор.Вставить("Группа", Группа);
	Отбор.Вставить("Ключ", Ключ);
	НайденныеСтроки = ИниФайлСтруктура.НайтиСтроки(Отбор);
	Если НайденныеСтроки.Количество() = 0 Тогда
		СтрИниФайлСтруктура = ИниФайлСтруктура.Добавить();
		СтрИниФайлСтруктура.Группа = Группа;
		СтрИниФайлСтруктура.Ключ = Ключ;
		СтрИниФайлСтруктура.Значение = Значение;
	Иначе
		НайденныеСтроки[0].Значение = Значение;
	КонецЕсли;
КонецПроцедуры

// Функция ДополнитьСлешВПуть
//
// Параметры:
// ИмяКаталога
//
// Описание:
// Функция дополняет и возвращает слеш в путь в конец строки, если он отсутствует
//
Функция ДополнитьСлешВПуть(Знач Каталог)
	Если Прав(Каталог, 1) <> "\" Тогда
		Каталог = Каталог + "\";
	КонецЕсли;
	Возврат Каталог;
КонецФункции

//Возвращает Рабочий каталог обработки: если он не был задан при инициализации, то "КаталогВременныхФайлов"
Функция КаталогРабочихФайлов()
	
	Если Не ЗначениеЗаполнено(мПараметры.РабочийКаталог) Тогда
		мПараметры.РабочийКаталог = КаталогВременныхФайлов();
	КонецЕсли;
	
	Возврат мПараметры.РабочийКаталог;
	
КонецФункции


// ======================= КОНЕЦ ОСНОВНОГО БЛОКА ======================= =========================
//
//} ======================= ======================= ======================= =======================


//{ ======================= БЛОК ЮНИТ-ТЕСТОВ - сами тесты ========================================
//
// ======================= ======================= ======================= ======================= 

Процедура ПередЗапускомТеста() Экспорт
	_тестируем = Истина;
	//РежимОтладки(Истина);
	
	П = ПолучитьПараметрыИнициализации();
	П.ПутьКФайлуХранилища1С = ПолучитьПутьКВременномуФайлуХранилища1С();
	
	П.ПользовательХранилища = "unit";
	П.ПарольХранилища = "";
	П.НомерВерсииХранилища = 2;
	
	П.Вставить("ВерсияПлатформыИБ", "8.3");
	
	Инициализация(П);
	
	ЗавершитьПроцесс_TGitCache_exe();
КонецПроцедуры

Процедура ПослеЗапускаТеста() Экспорт
	
	УдалитьВременныйФайлКонфигурации();
	
	УдалитьЗарегистрированныеВременныеФайлы();

	РежимОтладки(Ложь);
	мПараметры = Неопределено; // сброс инициализации
	
	_тестируем = Ложь;	
КонецПроцедуры

Процедура ТестДолжен_ЗарегистрироватьИУдалитьВременныеФайлы() Экспорт

	ВремФайл = Новый Файл(СоздатьВременныйФайл());
	ВремКаталог = Новый Файл(СоздатьВременныйКаталог());
	
	Сообщить("Файл: " + ВремФайл.ПолноеИмя);
	Сообщить("Каталог: " + ВремКаталог.ПолноеИмя);
	
	Проверить(ВремФайл.Существует(), "ВремФайл существует");
	Проверить(ВремКаталог.Существует(), "ВремКаталог существует");
	
	УдалитьЗарегистрированныеВременныеФайлы();
	
	юТест.ПроверитьЛожь(ВремФайл.Существует(), "ВремФайл удален");
	юТест.ПроверитьЛожь(ВремКаталог.Существует(), "ВремКаталог удален");

КонецПроцедуры

Процедура Тест_ДолженВыполнитьПолнуюВыгрузкуЧерезПараметрыЗапуска() Экспорт
	
	КаталогВыгрузки = СоздатьВременныйКаталог();
	МассивФайлов = НайтиФайлы(КаталогВыгрузки,"*.*");
	Проверить(МассивФайлов.Количество() = 0, "КаталогВыгрузки должен быть пуст");
	
	ПутьКФайлуКонфигурации = ПолучитьФайлКонфигурацииИзМакета();
	
	РазобратьФайлКонфигурации(ПутьКФайлуКонфигурации, КаталогВыгрузки);
	
	МассивФайлов = НайтиФайлы(КаталогВыгрузки,"*.*");
	Проверить(МассивФайлов.Количество() > 0, "в каталоге разложения модулей 1С <"+КаталогВыгрузки+"> должны быть файлы");

КонецПроцедуры

Процедура ТестДолжен_ВыполнитьКоммитФайловВГит() Экспорт

	КаталогВыгрузки = СоздатьВременныйКаталог();
	
	МассивФайлов = НайтиФайлы(КаталогВыгрузки,"*.*");
	Проверить(МассивФайлов.Количество() = 0, "КаталогВыгрузки должен быть пуст");
	
	ГитПодготовлен = ИнициализироватьТестовоеХранилищеГит(КаталогВыгрузки);
	юТест.ПроверитьРавенство(ГитПодготовлен, 0, "Код возврата git init должен быть равен нулю");
	
	ПутьКФайлуКонфигурации = ПолучитьФайлКонфигурацииИзМакета();

	РазобратьФайлКонфигурации(ПутьКФайлуКонфигурации, КаталогВыгрузки);
	
	МассивФайлов = НайтиФайлы(КаталогВыгрузки,"*.*");
	Проверить(МассивФайлов.Количество() > 0, "в каталоге разложения модулей 1С <"+КаталогВыгрузки+"> должны быть файлы");
	
	ВыполнитьКоммитГит(КаталогВыгрузки, "помещено из скрипта", "noreply <me@noreply.com>");
	
КонецПроцедуры
 
Процедура ТестДолжен_ПроверитьЧтениеФайлаАвторовГит() Экспорт
	
	КаталогРепозитория = СоздатьВременныйКаталог();
	СоздатьФайлАвторовГит_ДляТестов(КаталогРепозитория);
	ИмяФайлаАвторов = КаталогРепозитория + "\AUTHORS";
	ПроверитьСуществованиеФайлаКаталога(ИмяФайлаАвторов);
	
	ТаблицаПользователей = Неопределено;
	Если НЕ ПрочитатьФайлАвторовГит(ИмяФайлаАвторов, ТаблицаПользователей) Тогда
		ВызватьИсключение "Не удалось получить таблицу пользователей из гит 1С";
	КонецЕсли; 
	
	юТест.Проверить(ТаблицаПользователей <> Неопределено, "Таблица пользователей должна быть получена из процедуры ПрочитатьФайлАвторовГит");
	
	юТест.ПроверитьРавенство(ТаблицаПользователей[0].Автор, "Администратор", "Автор первой строки должен иметь значение Администратор");
	юТест.ПроверитьРавенство(ТаблицаПользователей[0].ПредставлениеАвтора, "Администратор <admin@localhost>", "Имя пользователя для Гит в строке 1 должно соответствовать шаблону");
	юТест.ПроверитьРавенство(ТаблицаПользователей[1].Автор, "Отладка", "Автор второй строки должен иметь значение Отладка");
	юТест.ПроверитьРавенство(ТаблицаПользователей[1].ПредставлениеАвтора, "Отладка <debug@localhost>", "Имя пользователя для Гит в строке 2 должно соответствовать шаблону");
	
КонецПроцедуры

Процедура ТестДолжен_ПроверитьОтсутствиеФайлаAUTHORS() Экспорт

	КаталогРепозитория = СоздатьВременныйКаталог();
	РезультатИнициализацииГитЧисло = ИнициализироватьТестовоеХранилищеГит(КаталогРепозитория);
	юТест.ПроверитьИстину(РезультатИнициализацииГитЧисло=0, "Инициализация git-хранилища в каталоге: "+КаталогРепозитория);
	
	ЗаписатьФайлВерсийГит(КаталогРепозитория,0);
	
	ПутьКФайлуХранилища1С = ПолучитьПутьКВременномуФайлуХранилища1С();
	
	резТаблицаИсторииХранилища = Неопределено;
	резТаблицаАвторовХранилища = Неопределено;
	резТаблицаПользователейГит = Неопределено;
	
	ТаблицыПрочитаны = ПолучитьТаблицуВерсийИзФайлаХранилищаГит(
							КаталогРепозитория, 
							ПутьКФайлуХранилища1С, 
							резТаблицаИсторииХранилища, 
							резТаблицаАвторовХранилища, 
							резТаблицаПользователейГит);
							
	Проверить(ТаблицыПрочитаны, "Чтение таблиц авторов должно быть корректно отработано");
	юТест.ПроверитьРавенство(резТаблицаПользователейГит.Количество(), 0, "Количество строк в проверяемой таблице должно быть равно эталону");
	
	// проверка алиасов по таблице истории хранилища
	ВывестиСообщение("1. Проверка: Если файл AUTHORS отсутствует -------");
	Для Каждого Стр Из резТаблицаИсторииХранилища Цикл
		ШаблонУтверждения = "алиас пользователя <%1> должен совпадать с эталоном";
		Если Стр.Автор = "Администратор" Тогда
			юТест.ПроверитьРавенство(Стр.ПредставлениеАвтора, "Администратор <Администратор@localhost>", ПодставитьПараметрыВСтроку(ШаблонУтверждения, Стр.Автор));
		ИначеЕсли Стр.Автор = "Отладка" Тогда
			юТест.ПроверитьРавенство(Стр.ПредставлениеАвтора, "Отладка <Отладка@localhost>", ПодставитьПараметрыВСтроку(ШаблонУтверждения, Стр.Автор));
		Иначе
			ВызватьИсключение "Неизвестный пользователь: " + Стр.Автор;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Процедура ТестДолжен_ПроверитьНеполнотуВФайлеAUTHORS() Экспорт

	КаталогРепозитория = СоздатьВременныйКаталог();
	РезультатИнициализацииГитЧисло = ИнициализироватьТестовоеХранилищеГит(КаталогРепозитория);
	юТест.ПроверитьИстину(РезультатИнициализацииГитЧисло=0, "Инициализация git-хранилища в каталоге: "+КаталогРепозитория);
	
	ЗаписатьФайлВерсийГит(КаталогРепозитория,0);
	
	ПутьКФайлуХранилища1С = ПолучитьПутьКВременномуФайлуХранилища1С();
	
	ФайлАвторов = Новый ЗаписьТекста;
	ФайлАвторов.Открыть(КаталогРепозитория+"\AUTHORS", "utf-8");
	ФайлАвторов.ЗаписатьСтроку("Администратор=Администратор <admin@localhost>");
	ФайлАвторов.Закрыть();
	
	резТаблицаИсторииХранилища = Неопределено;
	резТаблицаАвторовХранилища = Неопределено;
	резТаблицаПользователейГит = Неопределено;
	
	ТаблицыПрочитаны = ПолучитьТаблицуВерсийИзФайлаХранилищаГит(
							КаталогРепозитория, 
							ПутьКФайлуХранилища1С, 
							резТаблицаИсторииХранилища, 
							резТаблицаАвторовХранилища, 
							резТаблицаПользователейГит);
							
	Проверить(ТаблицыПрочитаны, "Чтение таблиц авторов должно быть корректно отработано");
	юТест.ПроверитьРавенство(резТаблицаПользователейГит.Количество(), 1, "Количество строк в проверяемой таблице должно быть равно эталону");
	
	Для Каждого Стр Из резТаблицаИсторииХранилища Цикл
		ШаблонУтверждения = "алиас пользователя <%1> должен совпадать с эталоном";
		Если Стр.Автор = "Администратор" Тогда
			юТест.ПроверитьРавенство(Стр.ПредставлениеАвтора, "Администратор <admin@localhost>", ПодставитьПараметрыВСтроку(ШаблонУтверждения, Стр.Автор));
		ИначеЕсли Стр.Автор = "Отладка" Тогда
			юТест.ПроверитьРавенство(Стр.ПредставлениеАвтора, "Отладка <Отладка@localhost>", ПодставитьПараметрыВСтроку(ШаблонУтверждения, Стр.Автор));
		Иначе
			ВызватьИсключение "Неизвестный пользователь: " + Стр.Автор;
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

Процедура ТестДолжен_ПроверитьДанныеВФайлеAUTHORS() Экспорт

	КаталогРепозитория = СоздатьВременныйКаталог();
	РезультатИнициализацииГитЧисло = ИнициализироватьТестовоеХранилищеГит(КаталогРепозитория);
	юТест.ПроверитьИстину(РезультатИнициализацииГитЧисло=0, "Инициализация git-хранилища в каталоге: "+КаталогРепозитория);
	
	ЗаписатьФайлВерсийГит(КаталогРепозитория,0);
	
	ПутьКФайлуХранилища1С = ПолучитьПутьКВременномуФайлуХранилища1С();
	
	юТест.ПроверитьЛожь(Новый Файл(КаталогРепозитория+"\AUTHORS").Существует());
	СоздатьФайлАвторовГит_ДляТестов(КаталогРепозитория);
	
	резТаблицаИсторииХранилища = Неопределено;
	резТаблицаАвторовХранилища = Неопределено;
	резТаблицаПользователейГит = Неопределено;
	
	ТаблицыПрочитаны = ПолучитьТаблицуВерсийИзФайлаХранилищаГит(
							КаталогРепозитория, 
							ПутьКФайлуХранилища1С, 
							резТаблицаИсторииХранилища, 
							резТаблицаАвторовХранилища, 
							резТаблицаПользователейГит);
							
	Проверить(ТаблицыПрочитаны, "Чтение таблиц авторов должно быть корректно отработано");
	юТест.ПроверитьРавенство(резТаблицаПользователейГит.Количество(), 2, "Количество строк в проверяемой таблице должно быть равно эталону");	
	
	ШаблонУтверждения = "алиас пользователя <%1> должен совпадать с эталоном";
	Стр = НайтиЗаписьВТаблице(резТаблицаПользователейГит, "Администратор", "Автор");
	юТест.ПроверитьЛожь(Стр = Неопределено, "Должен найти строку в таблице авторов");
	юТест.ПроверитьРавенство(Стр.ПредставлениеАвтора, "Администратор <admin@localhost>", ПодставитьПараметрыВСтроку(ШаблонУтверждения, Стр.Автор));
	Стр = НайтиЗаписьВТаблице(резТаблицаПользователейГит, "Отладка", "Автор");
	юТест.ПроверитьРавенство(Стр.ПредставлениеАвтора, "Отладка <debug@localhost>", ПодставитьПараметрыВСтроку(ШаблонУтверждения, Стр.Автор));

КонецПроцедуры

Функция ВыполнитьКлонированиеТестовогоРепо() Экспорт
	URLРепозитария = "http://stash.maxus.lan:7990/scm/aut/test.git";
	ИмяВетки       = "master";
	
	ЛокальныйРепозиторий = СоздатьВременныйКаталог();
	ФайлЛога = СоздатьВременныйФайл("log");
	Батник = СоздатьКомандныйФайл();
	ДобавитьВКомандныйФайл(Батник, "chcp 1251 > nul");
	ДобавитьВКомандныйФайл(Батник, ПодставитьПараметрыВСтроку("cd /d ""%1""", ЛокальныйРепозиторий));
	
	ПараметрыКоманды = Новый Массив;
	ПараметрыКоманды.Добавить(ОбернутьВКавычки(мПараметры.ПутьGit));
	ПараметрыКоманды.Добавить("clone");
	ПараметрыКоманды.Добавить(URLРепозитария);
	ПараметрыКоманды.Добавить(ОбернутьВКавычки("%CD%"));
	ПараметрыКоманды.Добавить(СуффиксПеренаправленияВывода(ФайлЛога, Истина));
	
	КоманднаяСтрока = СобратьКоманднуюСтроку(ПараметрыКоманды);
	ВывестиОтладочноеСообщение("Командная строка git clone:" + Символы.ПС + КоманднаяСтрока);
	ДобавитьВКомандныйФайл(Батник, КоманднаяСтрока);
	ДобавитьВКомандныйФайл(Батник, "exit /b %ERRORLEVEL%");
	
	РезультатКлонирования = ВыполнитьКомандныйФайл(Батник);
	// вывод всех сообщений от Git
	ВывестиТекстФайла(ФайлЛога);
	юТест.ПроверитьРавенство(РезультатКлонирования, 0, "git clone должен отработать успешно");
	
	Ответ = Новый Структура;
	Ответ.Вставить("ЛокальныйРепозиторий", ЛокальныйРепозиторий);
	Ответ.Вставить("URLРепозитария", URLРепозитария); 
	Ответ.Вставить("ИмяВетки", ИмяВетки);
	
	Возврат Ответ;
	
КонецФункции

Процедура ТестДолжен_ВыполнитьGitPush() Экспорт

	ВременныйРепо = ВыполнитьКлонированиеТестовогоРепо();
	
	СоздатьФайлАвторовГит_ДляТестов(ВременныйРепо.ЛокальныйРепозиторий);
	юТест.ПроверитьИстину(Новый Файл(ВременныйРепо.ЛокальныйРепозиторий+"\AUTHORS").Существует());
	
	ВыполнитьКоммитГит(ВременныйРепо.ЛокальныйРепозиторий, "test commit", "Администратор <admin@localhost>");
	
	КодВозврата = ВыполнитьGitPush(ВременныйРепо.ЛокальныйРепозиторий, ВременныйРепо.URLРепозитария, ВременныйРепо.ИмяВетки);
	юТест.ПроверитьРавенство(КодВозврата, 0, "Git должен завершиться с кодом 0");

КонецПроцедуры

Процедура ТестДолжен_ВыполнитьGitPull() Экспорт
	
	ВременныйРепо = ВыполнитьКлонированиеТестовогоРепо();
	
	КодВозврата = ВыполнитьGitPull(ВременныйРепо.ЛокальныйРепозиторий, ВременныйРепо.URLРепозитария, ВременныйРепо.ИмяВетки);
	юТест.ПроверитьРавенство(КодВозврата, 0, "Git должен завершиться с кодом 0");
	
КонецПроцедуры
 
Процедура Тест_ДолженСоздатьПустуюБазуПоФайлуКонфигурации() Экспорт
	лИмяКаталогаБазы = "";
	_Тест_ДолженСоздатьПустуюБазуПоФайлуКонфигурации(лИмяКаталогаБазы);
	_тест_СтруктураПараметров.Вставить("ИмяКаталогаБазы", лИмяКаталогаБазы);
КонецПроцедуры

Процедура Тест_ДолженСоздатьПустуюБазуПоФайлуКонфигурации_Платформа82() Экспорт
	лИмяКаталогаБазы = "";
	_Тест_ДолженСоздатьПустуюБазуПоФайлуКонфигурации(лИмяКаталогаБазы, "ТестовыйФайлКонфигурации_8_2_17");
	_тест_СтруктураПараметров.Вставить("ИмяКаталогаБазы", лИмяКаталогаБазы);
КонецПроцедуры

Процедура _Тест_ДолженСоздатьПустуюБазуПоФайлуКонфигурации(резИмяКаталогаБазы, имяМакета = "") Экспорт
	//ОВСЯНКИН ПутьКПлатформе1с83 = ПолучитьПутьПлатформы1С_83();
	
	лПутьКФайлуКонфигурации = ПолучитьФайлКонфигурацииИзМакета(имяМакета);
	
	_тест_СтруктураПараметров = Новый Структура;
		//		//СтруктураПараметров = Новый Структура("ПутьКДанным, ПутьКБазе, КаталогВыгрузки", ПутьКДанным, ПутьКБазе, _тест_ПутьКФайлуКонфигурации);
		//_тест_СтруктураПараметров.Вставить("ПутьКФайлуКонфигурации", лПутьКФайлуКонфигурации);
	
	лИмяКаталогаБазы = "";
	успешно = СоздатьПустуюБазу(лПутьКФайлуКонфигурации, лИмяКаталогаБазы); //СоздатьПустуюБазу(_тест_СтруктураПараметров);
		юТест.ПроверитьИстину(успешно, "создание пустой базы по cf");
	_тест_СтруктураПараметров.Вставить("ИмяКаталогаБазы", лИмяКаталогаБазы);
		
	лФайлБазы = Новый Файл(лИмяКаталогаБазы+"\1cv8.1cd"); //	лФайлБазы = Новый Файл(_тест_СтруктураПараметров.ИмяКаталогаБазы+"\1cv8.1cd");
		юТест.ПроверитьИстину(лФайлБазы.Существует(), "Не создана новая база 1С - не существует файл новой базы <"+лИмяКаталогаБазы+"\1cv8.1cd>");
		//юТест.ПроверитьИстину(лФайлБазы.Существует(), "Не создана новая база 1С - не существует файл новой базы <"+_тест_СтруктураПараметров.ИмяКаталогаБазы+"\1cv8.1cd>");
	резИмяКаталогаБазы = лИмяКаталогаБазы;
КонецПроцедуры

Процедура Тест_ДолженВыгрузитьМодули() Экспорт 
	//Тест_ДолженСоздатьПустуюБазуПоФайлуКонфигурации();		
	
	// лКаталогВыгрузкиВсехМодулей83 = "";
	
	// успешно = ВыгрузитьМодули(_тест_СтруктураПараметров.ИмяКаталогаБазы, "", "", лКаталогВыгрузкиВсехМодулей83);
			// //успешно = ВыгрузитьМодули(_тест_СтруктураПараметров.ИмяКаталогаБазы, _тест_СтруктураПараметров.Пользователь, _тест_СтруктураПараметров.Пароль, лКаталогВыгрузкиВсехМодулей83);
		// юТест.ПроверитьИстину(успешно, "выгрузить модули 1С");
	// _тест_СтруктураПараметров.Вставить("КаталогВыгрузкиВсехМодулей83", лКаталогВыгрузкиВсехМодулей83);
		
	// МассивФайлов = НайтиФайлы(лКаталогВыгрузкиВсехМодулей83,"*.*");
		// юТест.ПроверитьИстину(МассивФайлов.Количество() > 0, "в каталоге выгрузки модулей 1С <"+лКаталогВыгрузкиВсехМодулей83+"> должны быть файлы");
КонецПроцедуры

Процедура Тест_ДолженРазложитьМодули1СПоПапкамСогласноИерархииМетаданных() Экспорт 
	Тест_ДолженСоздатьПустуюБазуПоФайлуКонфигурации();		
	Тест_ДолженВыгрузитьМодули();
	
	лПутьКаталогаВыгрузкиДанных = СоздатьВременныйКаталог();
	_тест_СтруктураПараметров.Вставить("КаталогВыгрузки", лПутьКаталогаВыгрузкиДанных);
	
	успешно = РазложитьМодули1СПоПапкамСогласноИерархииМетаданных(_тест_СтруктураПараметров.КаталогВыгрузкиВсехМодулей83, лПутьКаталогаВыгрузкиДанных);
	
	юТест.ПроверитьИстину(успешно, "РазложитьМодули1СПоПапкамСогласноИерархииМетаданных");
	_тест_СтруктураПараметров.Вставить("ПутьКGit", лПутьКаталогаВыгрузкиДанных);
		
	лФайл = Новый Файл(лПутьКаталогаВыгрузкиДанных + "\renames.txt");
	юТест.ПроверитьИстину(лФайл.Существует(), "Не удалось разложим модули 1С по иерархии - не существует файл <"+лФайл.ПолноеИмя+">");
		
	МассивФайлов = НайтиФайлы(лПутьКаталогаВыгрузкиДанных,"*.*");
	юТест.ПроверитьИстину(МассивФайлов.Количество() > 0, "в каталоге разложения модулей 1С <"+лПутьКаталогаВыгрузкиДанных+"> должны быть файлы");
КонецПроцедуры

Процедура Тест_ДолженРазложитьМодули1СПоПапкамСогласноИерархииМетаданных_Платформа82() Экспорт 
	Тест_ДолженСоздатьПустуюБазуПоФайлуКонфигурации_Платформа82();		
	Тест_ДолженВыгрузитьМодули();
	
	лПутьКаталогаВыгрузкиДанных = СоздатьВременныйКаталог();
	_тест_СтруктураПараметров.Вставить("КаталогВыгрузки", лПутьКаталогаВыгрузкиДанных);
	
	успешно = РазложитьМодули1СПоПапкамСогласноИерархииМетаданных(_тест_СтруктураПараметров.КаталогВыгрузкиВсехМодулей83, лПутьКаталогаВыгрузкиДанных);

	юТест.ПроверитьИстину(успешно, "РазложитьМодули1СПоПапкамСогласноИерархииМетаданных");
	_тест_СтруктураПараметров.Вставить("ПутьКGit", лПутьКаталогаВыгрузкиДанных);
		
	лФайл = Новый Файл(лПутьКаталогаВыгрузкиДанных + "\renames.txt");
		юТест.ПроверитьИстину(лФайл.Существует(), "Не удалось разложим модули 1С по иерархии - не существует файл <"+лФайл.ПолноеИмя+">");
		
	МассивФайлов = НайтиФайлы(лПутьКаталогаВыгрузкиДанных,"*.*");
		юТест.ПроверитьИстину(МассивФайлов.Количество() > 0, "в каталоге разложения модулей 1С <"+лПутьКаталогаВыгрузкиДанных+"> должны быть файлы");
КонецПроцедуры

Процедура Тест_ДолженСоздатьПустуюБазуБезШаблона()
	
	успешно = СоздатьПустуюБазуБезШаблона(_тест_СтруктураПараметров);
	юТест.ПроверитьИстину(успешно, "Создание пустой базы, без шаблонов");
	
КонецПроцедуры

 Процедура _Тест_СобратьИзИерархииВЛинейнуюСтруктуру()
	
	юТест.ПроверитьИстину(_тест_СтруктураПараметров.Свойство("ПутьКGit"), "Не найден путь к каталогу выгрузки");
	_тест_СтруктураПараметров.Вставить("КаталогЗагрузки", _тест_СтруктураПараметров.ПутьКGit);
	успешно = СобратьМодули1СИзИерарархииМетаданныхВЛинейнуюСтруктуру(_тест_СтруктураПараметров);
	
	юТест.ПроверитьИстину(успешно, "Собрать из иерархии в линейную структуру");
	
	МассивФайлов = НайтиФайлы(_тест_СтруктураПараметров.ПутьКВременномуКаталогуПереименований,"*.*");
	юТест.ПроверитьИстину(МассивФайлов.Количество() > 0, "в каталоге линейной структуры модулей 1С <"+_тест_СтруктураПараметров.ПутьКВременномуКаталогуПереименований+"> должны быть файлы");
	
КонецПроцедуры

Процедура _Тест_ЗагрузитьМодулиКонфигурации() Экспорт
	
	юТест.ПроверитьИстину(_тест_СтруктураПараметров.Свойство("ПутьКВременномуКаталогуПереименований"), "Не найден путь к каталогу с xml выгрузкой");
	успешно = ЗагрузитьМодули(_тест_СтруктураПараметров);
		юТест.ПроверитьИстину(успешно, "Загрузка модулей не выполнена");
	
КонецПроцедуры


Процедура _Тест_СохранитьКонфигурациюВФайл() //Экспорт
	
		// юТест.ПроверитьИстину(_тест_СтруктураПараметров.Свойство("ИмяКаталогаБазы"), "Не найден путь к каталогу с xml выгрузкой");
	// _тест_СтруктураПараметров.Вставить("ПутьКФайлуКонфигурации", _ПолучитьИмяВременногоФайла(".cf"));
	
	// успешно = СохранитьКонфигурациюИзБазы(_тест_СтруктураПараметров.ПутьКФайлуКонфигурации, _тест_СтруктураПараметров.ИмяКаталогаБазы);
		// юТест.ПроверитьИстину(успешно, "Загрузка модулей не выполненна");
	
	// лФайл = Новый Файл(_тест_СтруктураПараметров.ПутьКФайлуКонфигурации);
		// юТест.ПроверитьИстину(лФайл.Существует(), "Не удалось сохранить cf  - не существует файл <"+лФайл.ПолноеИмя+">");
	
КонецПроцедуры

// TODO тест не работает, т.к. метод _Тест_СобратьИзИерархииВЛинейнуюСтруктуру собирает из временного
// каталога (пустого), а не из того каталога, в котором лежат XML файлы конфигурации
Процедура Тест_ДолженСобратьМодули1СИзПапокСогласноИерархииВОднуЛинейнуюПапку() Экспорт 
	/////////////////////
	// Отключение теста
	Возврат;
	/////////////////////
	
	// Тест_ДолженРазложитьМодули1СПоПапкамСогласноИерархииМетаданных();
	
	// _тест_СтруктураПараметров.КаталогВыгрузки = _тест_СтруктураПараметров.ПутьКGit;
	// _тест_СтруктураПараметров.Вставить("ПутьКФайлуКонфигурации", _ПолучитьИмяВременногоФайла(".cf"));
	// Тест_ДолженСоздатьПустуюБазуБезШаблона();
	// _Тест_СобратьИзИерархииВЛинейнуюСтруктуру();
	// _Тест_ЗагрузитьМодулиКонфигурации();
	// _Тест_СохранитьКонфигурациюВФайл();
	
		// //успешно = СобратьКонфигурацию1СПоПапкамСогласноИерархииМетаданных(_тест_СтруктураПараметров);
		// //	юТест.ПроверитьИстину(успешно, "РазложитьМодули1СПоПапкамСогласноИерархииМетаданных");
		// //	
	
	// лПутьКФайлуКонфигурации = ПолучитьФайлКонфигурацииИзМакета();
	// файлЭталон = Новый Файл(лПутьКФайлуКонфигурации);
	// ФайлНовый = Новый Файл(_тест_СтруктураПараметров.ПутьКФайлуКонфигурации);
	
	// юТест.ПроверитьИстину(ФайлНовый.Существует(), "новый файл конфигурации не существует");
	// юТест.ПроверитьИстину(файлЭталон.Существует(), "старый файл конфигурации не существует");
	
	// //юТест.ПроверитьИстину(ФайлНовый.Размер() = файлЭталон.Размер(), "цикл разборки и сборки не совпадает с эталонном "+файлЭталон.Размер() + " новый файл "+ФайлНовый.Размер());
	
КонецПроцедуры

Функция ПолучитьФайлКонфигурацииИзМакета(Знач имяМакета = "") 
	Если ИмяМакета = "" Тогда
		ИмяМакета = "ТестовыйФайлКонфигурации";
	КонецЕсли;
	
	ОтносительныйПуть = "testData\" + ИмяМакета + ".cf";
	
	ФайлТестовойКонфигурации = Новый Файл(ОтносительныйПуть);
	_тест_ПутьКФайлуКонфигурации = ФайлТестовойКонфигурации.ПолноеИмя;
	юТест.ПроверитьИстину(ФайлТестовойКонфигурации.Существует(), "не найден файл тестовой конфигурации <"+_тест_ПутьКФайлуКонфигурации+">");
	
	Возврат _тест_ПутьКФайлуКонфигурации;
	
КонецФункции

Процедура УдалитьВременныйФайлКонфигурации()
	// лФайл = Новый Файл(_тест_ПутьКФайлуКонфигурации);
	// Если лФайл.Существует() Тогда
		// Попытка
			// УдалитьФайлы(лФайл);
		// Исключение
		    // //ОписаниеОшибки()
		// КонецПопытки; 
	// КонецЕсли; 
КонецПроцедуры
 
Процедура Тест_ДолженПолучитьМаксимальнуюВерсию83() Экспорт
	путьПлатформ1С_83 = ПолучитьПутьПлатформы83();
	юТест.ПроверитьРавенство(путьПлатформ1С_83, "C:\Program Files (x86)\1cv8\8.3.3.721\bin\1cv8.exe");
КонецПроцедуры


Процедура Тест_ДолженУбратьОбрамляющиеКавычкиЕслиЕсть() Экспорт
	
	текст = """"+"W:\Конфигурации\"+"""";
	текстРез = УбратьОбрамляющиеКавычкиЕслиЕсть(текст);
		юТест.ПроверитьРавенство(текстРез, "W:\Конфигурации\");
		
	текст = "W:\Конфигурации\";
	текстРез = УбратьОбрамляющиеКавычкиЕслиЕсть(текст);
		юТест.ПроверитьРавенство(текстРез, "W:\Конфигурации\");
КонецПроцедуры

Процедура Тест_ДолженПолучитьФайлВерсийХранилища() Экспорт
	ПутьКХранилищу = ПолучитьПутьКВременномуФайлуХранилища1С();
	ПолучитьТестовыеФайлыXMLИзХранилища1С(ПутьКХранилищу);
КонецПроцедуры

Функция ПолучитьПутьКВременномуФайлуХранилища1С()
	
	ПутьКФайлуХранилища1С = Новый Файл("testData\ТестовыйФайлХранилища1С.1CD");
	юТест.ПроверитьИстину(ПроверитьСуществованиеФайлаКаталога(ПутьКФайлуХранилища1С.ПолноеИмя, "Тест_ДолженПолучитьФайлВерсийХранилища - ПутьКФайлуХранилища1С"));
	
	Возврат ПутьКФайлуХранилища1С.ПолноеИмя;
	
КонецФункции

Функция ПолучитьТестовыеФайлыXMLИзХранилища1С(Знач ПутьКФайлуХранилища)

	Результат = Новый Структура;
	
	ПутьКХМЛФайлуВерсийХранилища1С = "";
	ПутьКХМЛФайлуПользователейХранилища1С = "";
	
	успешно = ВыгрузитьТаблицыВерсийИПользователейИзФайлаХранилища1С(ПутьКФайлуХранилища, ПутьКХМЛФайлуВерсийХранилища1С, ПутьКХМЛФайлуПользователейХранилища1С);
	юТест.Проверить(успешно, "ВыгрузитьТаблицыВерсийИПользователейИзФайлаХранилища1С");
			
	лФайл = Новый Файл(ПутьКХМЛФайлуВерсийХранилища1С);
	юТест.ПроверитьИстину(лФайл.Существует(), "Не удалось получить файл истории хранилища 1С - не существует файл <"+ПутьКХМЛФайлуВерсийХранилища1С + ">");
		
	лФайл = Новый Файл(ПутьКХМЛФайлуПользователейХранилища1С);
	юТест.ПроверитьИстину(лФайл.Существует(), "Не удалось получить файл пользователей хранилища 1С - не существует файл <"+ПутьКХМЛФайлуПользователейХранилища1С + ">");
		
	Результат.Вставить("ФайлВерсий", ПутьКХМЛФайлуВерсийХранилища1С);
	Результат.Вставить("ФайлПользователей", ПутьКХМЛФайлуПользователейХранилища1С);
	
	Возврат Результат;
	
КонецФункции
 
Процедура Тест_ДолженПрочитатьФайлВерсийИзХранилища1С() Экспорт
	
	ПутиФайлов = ПолучитьТестовыеФайлыXMLИзХранилища1С(ПолучитьПутьКВременномуФайлуХранилища1С());
	
	лПутьФайлаВерсий = ПутиФайлов.ФайлВерсий;
	лФайл = Новый Файл(лПутьФайлаВерсий);
	юТест.ПроверитьИстину(лФайл.Существует(), "Не удалось получить файл истории хранилища 1С - не существует файл <"+лПутьФайлаВерсий + ">");
		
	таблицаИсторииХранилища = Неопределено;
	успешно = ПрочитатьФайлВерсийИзXML(лПутьФайлаВерсий, таблицаИсторииХранилища);
	юТест.Проверить(успешно, "Тест_ДолженПрочитатьФайлВерсийИзХранилища1С - ПрочитатьФайлВерсий");
	
	юТест.ПроверитьРавенство(таблицаИсторииХранилища.Количество(), 3, "таблицаИсторииХранилища.Количество()");
	
КонецПроцедуры

Процедура Тест_ДолженПрочитатьФайлПользователейИзХранилища1С() Экспорт
	ПутиФайлов = ПолучитьТестовыеФайлыXMLИзХранилища1С(ПолучитьПутьКВременномуФайлуХранилища1С());
	
	лПутьФайлаПользователей = ПутиФайлов.ФайлПользователей;
	лФайл = Новый Файл(лПутьФайлаПользователей);
	юТест.ПроверитьИстину(лФайл.Существует(), "Не удалось получить файл пользователей хранилища 1С - не существует файл <"+лПутьФайлаПользователей + ">");
		
	таблицаПользователейХранилища = Неопределено;
	успешно = ПрочитатьФайлПользователей(лПутьФайлаПользователей, таблицаПользователейХранилища);
	юТест.Проверить(успешно, "Тест_ДолженПрочитатьФайлПользователейИзХранилища1С - ПрочитатьФайлПользователей");
		
	юТест.ПроверитьРавенство(таблицаПользователейХранилища.Количество(), 2, "таблицаПользователейХранилища.Количество()");
	
КонецПроцедуры

Процедура Тест_ДолженПрочитатьФайлВерсийСИменамиПользователейИзХранилища1С() Экспорт 
	//_тест_СтруктураПараметров = Новый Структура;
	ПутьКФайлуХранилища1С = ПолучитьПутьКВременномуФайлуХранилища1С();//_тест_СтруктураПараметров.Вставить("ПутьКФайлуХранилища1С", _ПолучитьПутьКВременномуФайлуХранилища1С());
	
	ТаблицаИсторииХранилища = Неопределено;
	
	резПутьКХМЛФайлуВерсийХранилища1С = "";
	резПутьКХМЛФайлуПользователейХранилища1С = "";
	
	юТест.ПроверитьИстину(ВыгрузитьТаблицыВерсийИПользователейИзФайлаХранилища1С(ПутьКФайлуХранилища1С, резПутьКХМЛФайлуВерсийХранилища1С, резПутьКХМЛФайлуПользователейХранилища1С));
	
	успешно = ПрочитатьТаблицыХранилищаИзXML(резПутьКХМЛФайлуВерсийХранилища1С, резПутьКХМЛФайлуПользователейХранилища1С, таблицаИсторииХранилища, Неопределено);
	юТест.Проверить(успешно, "Тест_ДолженПрочитатьФайлВерсийСИменамиПользователейИзХранилища1С - ЭтотОбъект.ПрочитатьТаблицыХранилищаИзXML");
		
	//таблицаИсторииХранилища = _тест_СтруктураПараметров.ТаблицаИсторииХранилища;
	юТест.ПроверитьРавенство(таблицаИсторииХранилища.Количество(), 3, "таблицаИсторииХранилища.Количество()");
		
	//таблицаИсторииХранилища.ВыбратьСтроку();
	Для каждого строка Из таблицаИсторииХранилища Цикл
		Если ПустаяСтрока(строка.Автор) Тогда
			ВызватьИсключение "Не найден автор коммита - номер версии <"+строка.НомерВерсии+">, комментарий <"+строка.Комментарий+">";
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Процедура Тест_ДолженПодготовитьРепозитарийКСинхронизацииСХранилищем() Экспорт

	ТестФайлХранилища = ПолучитьПутьКВременномуФайлуХранилища1С();
	
	// запись
	ВыходнойФайл = СоздатьВременныйФайл("");
	СформироватьПервичныйФайлПользователейДляGit(ТестФайлХранилища, ВыходнойФайл);
	// проверка
	Стр = "";
	СчетчикПроверки = 0;
	СтрокиПроверки = Новый Массив;
	СтрокиПроверки.Добавить("Администратор=Администратор <Администратор@localhost>");
	СтрокиПроверки.Добавить("Отладка=Отладка <Отладка@localhost>");
	
	ЧтениеФайла = Новый ЧтениеТекста(ВыходнойФайл, "utf-8");
	
	Попытка
		
		Пока Стр <> Неопределено Цикл
			Стр = ЧтениеФайла.ПрочитатьСтроку();
			Если Стр <> Неопределено Тогда
				юТест.Проверить(СчетчикПроверки < СтрокиПроверки.Количество(), "Количество строк в файле должно совпадать с эталоном");
			Иначе
				Прервать;
			КонецЕсли;
			
			юТест.ПроверитьРавенство(СтрокиПроверки[СчетчикПроверки], Стр, "Строка в файле должна совпадать с эталоном");
			СчетчикПроверки = СчетчикПроверки + 1;
			
		КонецЦикла;
		ЧтениеФайла.Закрыть();
	Исключение
		ОсвободитьОбъект(ЧтениеФайла);
		ВызватьИсключение;
	КонецПопытки;
	
	юТест.ПроверитьРавенство(СчетчикПроверки, СтрокиПроверки.Количество(), "Количество прочитанных строк не соответствует эталону");

КонецПроцедуры

Процедура Тест_ТестДолженПоНомеруВерсииСохранитьКонфигурациюИзХранилища1С() Экспорт
	лНомерВерсииХранилища = 2;
	
	//_тест_СтруктураПараметров = Новый Структура;
	//_тест_СтруктураПараметров.Вставить("ПутьКФайлуХранилища1С", _ПолучитьПутьКВременномуФайлуХранилища1С());
	//_тест_СтруктураПараметров.Вставить("ПутьКХранилищу1C", "tcp://ws-msk-a2354:3542/1C2Git");
	//_тест_СтруктураПараметров.Вставить("НомерВерсииХранилища", лНомерВерсииХранилища);
	//
	//_тест_СтруктураПараметров.Вставить("Пользователь", "");
	//_тест_СтруктураПараметров.Вставить("Пароль", "");
	//_тест_СтруктураПараметров.Вставить("ПользовательХранилища", "Отладка");
	//_тест_СтруктураПараметров.Вставить("ПарольХранилища", "");
	//
	//_тест_СтруктураПараметров.Вставить("ПутьКБазе", "File=""W:\Конфигурации\Связной\1C2Git_Отладка""");
	//_тест_СтруктураПараметров.Вставить("версияПлатформыДляБазы", ""); //8.3
	//
	//	//_тест_СтруктураПараметров.Вставить("ПутьКХранилищу1C", "tcp://repository17/1CUnit\");
	//	//_тест_СтруктураПараметров.Вставить("НомерВерсииХранилища", лНомерВерсииХранилища);
	//	//
	//	//_тест_СтруктураПараметров.Вставить("Пользователь", "Администратор");
	//	//_тест_СтруктураПараметров.Вставить("Пароль", "");
	//	//_тест_СтруктураПараметров.Вставить("ПользовательХранилища", "aayuhanov");
	//	//_тест_СтруктураПараметров.Вставить("ПарольХранилища", "1");
	//	//
	//	//_тест_СтруктураПараметров.Вставить("ПутьКБазе", "File=""W:\Конфигурации\Разработка\1CUnit\ТестоваяБаза""");
	//	
	//Параметры = _тест_СтруктураПараметров;
	
	П = ПараметрыПоУмолчанию_1C2Git();
	П.Вставить("НомерВерсииХранилища", лНомерВерсииХранилища);
	
	ПутьКФайлуКонфигурации = "";
	успешно = ПоНомеруВерсииСохранитьКонфигурациюИзХранилища1С(П.ПутьКБазе, П.версияПлатформыДляБазы, П.Пользователь, П.Пароль, П.ПутьКХранилищу1C, 
		П.ПользовательХранилища, П.ПарольХранилища, П.ПутьКФайлуХранилища1С, П.НомерВерсииХранилища, ПутьКФайлуКонфигурации); //ЭтотОбъект.
		
		юТест.Проверить(успешно, "ПоНомеруВерсииСохранитьКонфигурациюИзХранилища1С - Тест_ТестДолженПоНомеруВерсииСохранитьКонфигурациюИзХранилища1С");
		юТест.Проверить(ПроверитьСуществованиеФайлаКаталога(ПутьКФайлуКонфигурации), "ПроверитьСуществованиеФайлаКаталога(ПутьКФайлуКонфигурации) - Тест_ТестДолженПоНомеруВерсииСохранитьКонфигурациюИзХранилища1С");
КонецПроцедуры

Функция ПараметрыПоУмолчанию_1C2Git()
	П = Новый Структура;
	П.Вставить("ПутьКФайлуХранилища1С", ПолучитьПутьКВременномуФайлуХранилища1С());
	П.Вставить("ПутьКХранилищу1C", "tcp://ws-msk-a2354:3542/1C2Git");
	
	П.Вставить("Пользователь", "");
	П.Вставить("Пароль", "");
	П.Вставить("ПользовательХранилища", "unit");
	П.Вставить("ПарольХранилища", "");
	П.Вставить("НомерВерсииХранилища", 0);
	
	П.Вставить("ПутьКБазе", "File=""F:\1C2Git_Отладка""");//"File=""W:\Конфигурации\Связной\1C2Git_Отладка""");
	П.Вставить("версияПлатформыДляБазы", "8.3");
	
	П.Вставить("КаталогВыгрузки", СоздатьВременныйКаталог());
	П.Вставить("КаталогВыгрузкиВсехМодулей83", СоздатьВременныйКаталог());
	
		//_тест_СтруктураПараметров.Вставить("ПутьКХранилищу1C", "tcp://repository17/1CUnit\");
		//_тест_СтруктураПараметров.Вставить("НомерВерсииХранилища", лНомерВерсииХранилища);
		//
		//_тест_СтруктураПараметров.Вставить("Пользователь", "Администратор");
		//_тест_СтруктураПараметров.Вставить("Пароль", "");
		//_тест_СтруктураПараметров.Вставить("ПользовательХранилища", "aayuhanov");
		//_тест_СтруктураПараметров.Вставить("ПарольХранилища", "1");
		//
		//_тест_СтруктураПараметров.Вставить("ПутьКБазе", "File=""W:\Конфигурации\Разработка\1CUnit\ТестоваяБаза""");
	
	_тест_СтруктураПараметров = П;
	Возврат П;
КонецФункции
 
Процедура Тест_ТестДолженПоНомеруВерсииРазобратьКонфигурациюИзХранилища1С() Экспорт
	лНомерВерсииХранилища = 2;
	
	П = ПараметрыПоУмолчанию_1C2Git();
	П.Вставить("НомерВерсииХранилища", лНомерВерсииХранилища);
	
	резПутьКФайлуКонфигурации = "";
	успешно = ПоНомеруВерсииРазобратьКонфигурациюИзХранилища1С(П.ПутьКБазе, П.версияПлатформыДляБазы, П.Пользователь, П.Пароль, П.ПутьКХранилищу1C, 
		П.ПользовательХранилища, П.ПарольХранилища, П.ПутьКФайлуХранилища1С, П.НомерВерсииХранилища, П.КаталогВыгрузкиВсехМодулей83, П.КаталогВыгрузки, 
		резПутьКФайлуКонфигурации);
		
		юТест.Проверить(успешно, "вызов ПоНомеруВерсииРазобратьКонфигурациюИзХранилища1С - Тест_ТестДолженПоНомеруВерсииРазобратьКонфигурациюИзХранилища1С");
		
	ПутьКGit = П.КаталогВыгрузки;
	
		лФайл = Новый Файл(ПутьКGit + "\renames.txt");
			юТест.ПроверитьИстину(лФайл.Существует(), "Не удалось разложить модули 1С по иерархии - не существует файл <"+лФайл.ПолноеИмя+">");
			
		МассивФайлов = НайтиФайлы(ПутьКGit,"*.*");
			юТест.ПроверитьИстину(МассивФайлов.Количество() > 0, "в каталоге разложения модулей 1С <"+П.КаталогВыгрузки+"> должны быть файлы");
КонецПроцедуры

Процедура Тест_ДолженРазложитьМодули1СпоНомеруВерсииХранилища1С() Экспорт 
	П = ПараметрыПоУмолчанию_1C2Git();
	
	//Тест_ДолженСоздатьПустуюБазуПоФайлуКонфигурации();		
	//Тест_ДолженВыгрузитьМодули();
	
	лПутьКаталогаВыгрузкиДанных = П.КаталогВыгрузки;
		//лПутьКаталогаВыгрузкиДанных = ПолучитьВременноеИмяКаталога(); //СтрЗаменить(_ПолучитьИмяВременногоФайла("сtr"), ".сtr", "");
		//П.Вставить("КаталогВыгрузки", лПутьКаталогаВыгрузкиДанных);
	
	//П = _тест_СтруктураПараметров;
	
	успешно = РазложитьМодули1СпоНомеруВерсииХранилища1С(П.ПутьКБазе, П.ВерсияПлатформыДляБазы, П.Пользователь, П.Пароль, П.ПутьКХранилищу1C, 
		П.ПользовательХранилища, П.ПарольХранилища, П.ПутьКФайлуХранилища1С, П.НомерВерсииХранилища, П.КаталогВыгрузки, П.КаталогВыгрузкиВсехМодулей83, 
		"");
	
	//успешно = РазложитьМодули1СпоНомеруВерсииХранилища1С(_тест_СтруктураПараметров.КаталогВыгрузкиВсехМодулей83, лПутьКаталогаВыгрузкиДанных);
	////	ВывестиСообщение("Не удалось выполнить копирование файлов");
	////	Возврат Ложь;
	////КонецЕсли; 
	
	//успешно = РазложитьМодули1СПоПапкамСогласноИерархииМетаданных(_тест_СтруктураПараметров);
		юТест.ПроверитьИстину(успешно, "РазложитьМодули1СПоПапкамСогласноИерархииМетаданных");
	//_тест_СтруктураПараметров.Вставить("ПутьКGit", лПутьКаталогаВыгрузкиДанных);
		
	лФайл = Новый Файл(лПутьКаталогаВыгрузкиДанных + "\renames.txt");
		юТест.ПроверитьИстину(лФайл.Существует(), "Не удалось разложим модули 1С по иерархии - не существует файл <"+лФайл.ПолноеИмя+">");
		
	МассивФайлов = НайтиФайлы(лПутьКаталогаВыгрузкиДанных,"*.*");
		юТест.ПроверитьИстину(МассивФайлов.Количество() > 0, "в каталоге разложения модулей 1С <"+лПутьКаталогаВыгрузкиДанных+"> должны быть файлы");
КонецПроцедуры

Функция ИнициализироватьТестовоеХранилищеГит(Знач КаталогРепозитория)

	ПутьGit = """"+мПараметры.ПутьGit + """";
	Возврат ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(ПутьGit+" init", КаталогРепозитория);
	
КонецФункции

Процедура СоздатьФайлАвторовГит_ДляТестов(Знач Каталог)

	ФайлАвторов = Новый ЗаписьТекста;
	ФайлАвторов.Открыть(Каталог+"\AUTHORS", "utf-8");
	ФайлАвторов.ЗаписатьСтроку("Администратор=Администратор <admin@localhost>");
	ФайлАвторов.ЗаписатьСтроку("Отладка=Отладка <debug@localhost>");
	ФайлАвторов.Закрыть();

КонецПроцедуры

Процедура ТестДолжен_СинхронизироватьХранилищеКонфигурацийСГит() Экспорт	
	
	П = Новый Структура;
	П.Вставить("ПутьКФайлуХранилища1С", ПолучитьПутьКВременномуФайлуХранилища1С());
	
	П.Вставить("Пользователь", "");
	П.Вставить("Пароль", "");
	П.Вставить("ПользовательХранилища", "unit");
	П.Вставить("ПарольХранилища", "");
	П.Вставить("НомерВерсииХранилища", 0);
	
	КаталогРепо = СоздатьВременныйКаталог();
	КаталогИсходников = КаталогРепо + "\src";
	СоздатьКаталог(КаталогИсходников);
	
	П.Вставить("КаталогВыгрузки", КаталогИсходников);
	П.Вставить("КаталогВыгрузкиВсехМодулей83", СоздатьВременныйКаталог());
	
	лПутьКаталогаВыгрузкиДанных = П.КаталогВыгрузки;
	
	РезультатИнициализацииГитЧисло = ИнициализироватьТестовоеХранилищеГит(КаталогРепо);
	юТест.ПроверитьИстину(РезультатИнициализацииГитЧисло=0, "Инициализация git-хранилища в каталоге: "+КаталогРепо);
	
	СоздатьФайлАвторовГит_ДляТестов(лПутьКаталогаВыгрузкиДанных);
	юТест.ПроверитьИстину(Новый Файл(лПутьКаталогаВыгрузкиДанных+"\AUTHORS").Существует());
	ЗаписатьФайлВерсийГит(лПутьКаталогаВыгрузкиДанных,0);
	ПроверитьСуществованиеФайлаКаталога(лПутьКаталогаВыгрузкиДанных+"\VERSION");
	
	РезультатСинхронизации = СинхронизироватьХранилищеКонфигурацийСГит(П);
	юТест.ПроверитьИстину(РезультатСинхронизации, "СинхронизироватьХранилищеКонфигурацийСГит");
	
	ПутьGit = ОбернутьВКавычки(мПараметры.ПутьGit);

	ИмяФайлаЛогаГит = СоздатьВременныйФайл("txt");
	
	ФайлКоманды = СоздатьКомандныйФайл();
	ДобавитьВКомандныйФайл(ФайлКоманды, "cd /d " + ОбернутьВКавычки(лПутьКаталогаВыгрузкиДанных));
	ДобавитьВКомандныйФайл(ФайлКоманды, ПутьGit+" log --pretty=oneline >"+ОбернутьВКавычки(ИмяФайлаЛогаГит));
	РезультатВыводаЛогаГитЧисло = ВыполнитьКомандныйФайл(ФайлКоманды);
	
	юТест.ПроверитьРавенство(0, РезультатВыводаЛогаГитЧисло, "Получение краткого лога хранилища git");
	
	ЛогГит = Новый ЧтениеТекста;
	ЛогГит.Открыть(ИмяФайлаЛогаГит);
	КоличествоКоммитов = 0;
	Пока ЛогГит.ПрочитатьСтроку() <> Неопределено Цикл
		КоличествоКоммитов = КоличествоКоммитов + 1;
	КонецЦикла;
	ЛогГит.Закрыть();
	юТест.ПроверитьРавенство(КоличествоКоммитов, 3, "Количество коммитов в git-хранилище");
	
	ЗавершитьПроцесс_TGitCache_exe();
	
КонецПроцедуры
	
Процедура ТестДолжен_ОпределитьЧтоТребуетсяСинхронизацияСГит() Экспорт
	
	П = Новый Структура;
	П.Вставить("ПутьКФайлуХранилища1С", ПолучитьПутьКВременномуФайлуХранилища1С());
	
	П.Вставить("Пользователь", "");
	П.Вставить("Пароль", "");
	П.Вставить("ПользовательХранилища", "unit");
	П.Вставить("ПарольХранилища", "");
	П.Вставить("НомерВерсииХранилища", 0);
	
	КаталогРепо = СоздатьВременныйКаталог();
	КаталогИсходников = КаталогРепо + "\src";
	СоздатьКаталог(КаталогИсходников);
	
	П.Вставить("КаталогВыгрузки", КаталогИсходников);
	П.Вставить("КаталогВыгрузкиВсехМодулей83", СоздатьВременныйКаталог());
	
	лПутьКаталогаВыгрузкиДанных = П.КаталогВыгрузки;
	
	РезультатИнициализацииГитЧисло = ИнициализироватьТестовоеХранилищеГит(КаталогРепо);
	юТест.ПроверитьИстину(РезультатИнициализацииГитЧисло=0, "Инициализация git-хранилища в каталоге: "+КаталогРепо);
	
	СоздатьФайлАвторовГит_ДляТестов(лПутьКаталогаВыгрузкиДанных);
	юТест.ПроверитьИстину(Новый Файл(лПутьКаталогаВыгрузкиДанных+"\AUTHORS").Существует());
	ЗаписатьФайлВерсийГит(лПутьКаталогаВыгрузкиДанных,0);
	ПроверитьСуществованиеФайлаКаталога(лПутьКаталогаВыгрузкиДанных+"\VERSION");
	
	юТест.ПроверитьИстину(ТребуетсяСинхронизироватьХранилищеСГит(П.ПутьКФайлуХранилища1С, КаталогИсходников));
	
КонецПроцедуры
	
_тестируем = Ложь;
юТест = Неопределено;

// ======================= ======================= ======================= ======================= 
//
// КОНЕЦ БЛОКА ЮНИТ-ТЕСТОВ
//
//} ======================= ======================= ======================= =======================

мРежимОтладки = Ложь;
мРежимУплотнения = Ложь;
мРежимСохраненияАрхивов = Ложь;
мНомерОчереди = 0;
мОсталосьОпераций = 1;